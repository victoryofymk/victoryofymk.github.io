<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx简介(一)]]></title>
    <url>%2F2018%2F11%2F14%2Fnginx%E7%AE%80%E4%BB%8B(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[版本更新之前，nginx 默认支持http，如果要转发tcp需要安装第三方模块，在1.9.0之后的版本增加了stream模块用于一般的TCP代理和负载均衡。 The ngx_stream_core_module module is available since version 1.9.0. This module is not built by default, it should be enabled with the --with-stream configuration parameter. ngx_stream_core_module 。 这个模块在1.90版本后将被启用。但是并不会默认安装，需要在编译时通过指定 –with-stream 参数来激活这个模块。所以，我们如果需要用到这个功能，就需要加上 –with-stream 参数重新编译nginx。对于已在线上运行的nginx，你可能要用到平滑升级来避免线上的服务被中断，可以参考网上教程。 –with-http_ssl_module 模块支持https，默认没有安装，需要对原有的nginx进行平滑升级，同时需要一些其他配置库，对现有的nginx配置可以使用 nginx -V查询 nginx version: nginx/1.10.2 built by clang 8.0.0 (clang-800.0.42.1) built with OpenSSL 1.1.0c 10 Nov 2016 (running with OpenSSL 1.1.0f 25 May 2017) TLS SNI support enabled configure arguments: --prefix=/usr/local/Cellar/nginx/1.10.2_1 --with-http_ssl_module --with-pcre --sbin-path=/usr/local/Cellar/nginx/1.10.2_1/bin/nginx --with-cc-opt=&apos;-I/usr/local/opt/pcre/include -I/usr/local/opt/openssl@1.1/include&apos; --with-ld-opt=&apos;-L/usr/local/opt/pcre/lib -L/usr/local/opt/openssl@1.1/lib&apos; --conf-path=/usr/local/etc/nginx/nginx.conf --pid-path=/usr/local/var/run/nginx.pid --lock-path=/usr/local/var/run/nginx.lock --http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp --http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp --http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp --http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp --http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp --http-log-path=/usr/local/var/log/nginx/access.log --error-log-path=/usr/local/var/log/nginx/error.log --with-http_gzip_static_module --with-ipv6]]></content>
      <categories>
        <category>nginx教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(七)：vue使用中的问题]]></title>
    <url>%2F2018%2F10%2F29%2Fvue%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见问题i-table的render方法this指向windowi-table 中render渲染的方法this指向window 解决办法:定义VUE时使用变量接收1let vue=new VUE（｛｝） 淘宝镜像1ERROR command failed: npm install --loglevel error --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist 编辑.vuerc，修改配置”useTaobaoRegistry”: false1vi ~/.vuerc]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(六)：vue-resource HTTP介绍]]></title>
    <url>%2F2018%2F10%2F28%2Fvue-resource%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[HTTP可以使用全局的 Vue.http 或者在 Vue 实例中的 this.$http 调用 http 服务。 使用Vue 实例提供了 this.$http 服务可用于发送 HTTP 请求。 A request method call returns a Promise that resolves to the response. Vue 实例在所有回调方法中都会自动绑定到 this 里。12345678&#123; // GET /someUrl this.$http.get(&apos;/someUrl&apos;).then((response) =&gt; &#123; // success callback &#125;, (response) =&gt; &#123; // error callback &#125;);&#125; 方法所有的请求类型都可以使用短函数，可以在全局或者 Vue 实例中使用。 // 全局 Vue 对象12Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback); // Vue 实例12this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback); 短方法清单：1234567get(url, [options])head(url, [options])delete(url, [options])jsonp(url, [options])post(url, [body], [options])put(url, [body], [options])patch(url, [body], [options]) 选项123456789101112参数 类型 描述url string 请求发送到的 URLbody Object, FormData, string 请求中要发送的数据headers Object 作为 HTTP 请求头发送的 Headers 对象params Object 作为 URL 参数发送的 Parameters 对象method string HTTP 方法 (例如： GET, POST, ...)timeout number 请求超时的毫秒数 (0 为不超时)before function(request) 在请求发送之前用于修改请求选项的回调函数progress function(event) 上传时用于控制 ProgressEvent 的回调函数credentials boolean Indicates whether or not cross-site Access-Control requests should be made using credentialsemulateHTTP boolean 使用 HTTP POST 发送 PUT, PATCH 和 DELETE 请求并设置 X-HTTP-Method-Override 头emulateJSON boolean 以 application/x-www-form-urlencoded 内容类型发送请求报文 响应通过下面的属性和函数将请求解析为响应对象：1234567891011属性 类型 描述url string 响应的源 URLbody Object, Blob, string 响应的数据报文headers Header 响应头对象ok boolean 从 200 到 299 的 HTTP 状态码status number 响应中的 HTTP 状态码statusText string 响应中的 HTTP 状态文本函数 类型 描述text() Promise 作为字符串解析报文json() Promise 作为 Json 对象解析报文blob() Promise 作为 Blob 对象解析报文 实例1234567891011121314151617181920&#123; // POST /someUrl this.$http.post(&apos;/someUrl&apos;, &#123;foo: &apos;bar&apos;&#125;).then((response) =&gt; &#123; // get status response.status; // get status text response.statusText; // get &apos;Expires&apos; header response.headers.get(&apos;Expires&apos;); // set data on vm this.$set(&apos;someData&apos;, response.body); &#125;, (response) =&gt; &#123; // error callback &#125;);&#125; 获取图像并使用 blob() 方法来从响应中提取图像正文内容。1234567891011&#123; // GET /image.jpg this.$http.get(&apos;/image.jpg&apos;).then((response) =&gt; &#123; // resolve to Blob return response.blob(); &#125;).then(blob) =&gt; &#123; // use image Blob &#125;);&#125; 拦截器可以全局定义一个拦截器，用于预处理和后处理的请求。 请求处理12345678910111213141516171819202122Vue.http.interceptors.push((request, next) =&gt; &#123; // modify request request.method = &apos;POST&apos;; // continue to next interceptor next();&#125;);请求和响应处理Vue.http.interceptors.push((request, next) =&gt; &#123; // modify request request.method = &apos;POST&apos;; // continue to next interceptor next((response) =&gt; &#123; // modify response response.body = &apos;...&apos;; &#125;);&#125;); 返回一个响应并停止处理12345678910Vue.http.interceptors.push((request, next) =&gt; &#123; // modify request ... // stop and return response next(request.respondWith(body, &#123; status: 404, statusText: &apos;Not found&apos; &#125;));&#125;);]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(五)：vue-cli 3.0使用教程]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-cli3.0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[webpack路径别名，@ 等价于 /src 这个目录1import Hello from &apos;@/components/Hello&apos; vue-cli 3.0配置webpackvue-cli提供的是3.0.0-beta.6版本，简化成使用vue.config.js来配置项目 在根目录新建vue.config.js1234567891011const path = require(&apos;path&apos;);function resolve (dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; lintOnSave: true, chainWebpack: (config)=&gt;&#123; config.resolve.alias .set(&apos;@$&apos;, resolve(&apos;src&apos;)) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// vue.config.js 配置说明//官方vue.config.js 参考文档 https://cli.vuejs.org/zh/config/#css-loaderoptions// 这里只列一部分，具体配置参考文档module.exports = &#123; // 部署生产环境和开发环境下的URL。 // 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上 //例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 baseUrl 为 /my-app/。 baseUrl: process.env.NODE_ENV === &quot;production&quot; ? &quot;./&quot; : &quot;/&quot;, // outputDir: 在npm run build 或 yarn build 时 ，生成文件的目录名称（要和baseUrl的生产环境路径一致） outputDir: &quot;mycli3&quot;, //用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下） assetsDir: &quot;assets&quot;, //指定生成的 index.html 的输出路径 (打包之后，改变系统默认的index.html的文件名) // indexPath: &quot;myIndex.html&quot;, //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变) filenameHashing: false, // lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint lintOnSave: true, //如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置 // lintOnSave: process.env.NODE_ENV !== &apos;production&apos;, //是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false) // runtimeCompiler: false, /** * 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。 * 打包之后发现map文件过大，项目文件体积很大，设置为false就可以不输出map文件 * map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。 * 有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。 * */ productionSourceMap: false, // 它支持webPack-dev-server的所有选项 devServer: &#123; host: &quot;localhost&quot;, port: 1111, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: true, //配置自动启动浏览器 // proxy: &apos;http://localhost:4000&apos; // 配置跨域处理,只有一个代理 // 配置多个代理 proxy: &#123; &quot;/api&quot;: &#123; target: &quot;&lt;url&gt;&quot;, ws: true, changeOrigin: true &#125;, &quot;/foo&quot;: &#123; target: &quot;&lt;other_url&gt;&quot; &#125; &#125; &#125;&#125;; 组件封装import默认会找该目录下index.js的文件，新增一个组件可以创建一个目录name,在里面创建index.js导入使用如下代码：1import &apos;./name&apos; 生命周期钩子：常用如下：1234Created：vue实例被生成后的一个生命周期钩子函数。(页面初始化数据加载一般写这里);beforeCreate：给个loading界面 created撤销loading;beforeDestory：你确认删除XX吗？destoryed：当前组件已被删除，清空相关内容 vue组件的声明周期 scssnpm install node-sass –save-devnpm install sass-loader –save-dev]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(四)：引入iview]]></title>
    <url>%2F2018%2F10%2F26%2Fvue%E5%BC%95%E5%85%A5iview%2F</url>
    <content type="text"><![CDATA[环境基础vue-cli 3.x搭建环境 安装npm安装NPM安装 iView1npm i -S iview 全局引入一般在 webpack 入口页面 main.js 中如下配置：1234import iView from &apos;iview&apos;;import &apos;iview/dist/styles/iview.css&apos;;Vue.use(iView); 會出現 iView is unidefined,正確的配置src/iview/index.js import iview from ‘iview’前面的 iview 要用小寫12345import Vue from &quot;vue&quot;;import iview from &quot;iview&quot;;import &quot;iview/dist/styles/iview.css&quot;;Vue.use(iview); src/main.js加入這一行即可1import &quot;./iview&quot;; 注意：babel.config.js中的plugins配置要删除，否则会引起冲突 按需引入修改babel.config.js，添加下面配置123456789&quot;plugins&quot;: [ [ &quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;iview&quot;, &quot;libraryDirectory&quot;: &quot;src/components&quot; &#125; ] ] 如果您想在 webpack 中按需使用组件，减少文件体积，可以这样写：123import &#123; Button, Table &#125; from &apos;iview&apos;;Vue.component(&apos;Button&apos;, Button);Vue.component(&apos;Table&apos;, Table); 提醒：*按需引用仍然需要导入样式，即在 main.js或根组件执行 import ‘iview/dist/styles/iview.css’;* 注意：尽量使用index.js中的命名，避免使用vue内置的名字，否则会引起错误 vue-ui安装自定义配置：此时很多朋友会问了，没有配置文件，那我需要自定义一个配置咋办呢？莫慌，此时我们只需要在项目根目录新建一个 vue.config.js 文件就能使用自定义配置了12345678module.exports = &#123; baseUrl: process.env.NODE_ENV === &apos;production&apos; ? &apos;/production-sub-path/&apos; : &apos;/&apos;, devServer: &#123; port: 8000 &#125;&#125; 组件使用规范12345678910111213141516a、动态传值，使用 :prop = &apos;&apos;b、在非 template/render 模式下（例如使用 CDN 引用时）， 组件名要分隔（驼峰命名改为烤肉串），例如 DatePicker 必须要写成 date-pickerc、以下组件，在非 template/render 模式下，需要加前缀 i-： ·Button: i-button ·Col: i-col ·Table: i-table ·Input: i-input ·Form: i-form ·Menu: i-menu ·Select: i-select ·Option: i-option ·Progress: i-progress 以下组件，在所有模式下，必须加前缀 i-，除非使用 iview-loader： ·Switch: i-switch ·Circle: i-circle 问题使用箭头函数this为空,箭头函数会改变this指向 Try changing the iView import statement to the following: import iView from ‘iview/dist/iview.min’;Frequently you’ll find that distribution packages contain the production version of the library located within a dist directory. Seeing as the stylesheet is located there, I’d assume the js is there as well. // likely that the iview js in this directoryimport ‘iview/dist/styles/iview.css’;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(三)：安装vue-cli 3.x]]></title>
    <url>%2F2018%2F10%2F25%2Fvue%E5%AE%89%E8%A3%85vue-cli3.x%2F</url>
    <content type="text"><![CDATA[安装安装vue-cli1npm install --g @vue/cli 创建模板项目1vue create 【项目名称】 项目结构通过cli 3.x 新建的项目的结构较之前简单，只有 public 和 src 两个文件夹 安装依赖1npm install 配置启动脚本(packge.json &gt; script)12345678&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve --open&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;, &quot;test:e2e&quot;: &quot;vue-cli-service test:e2e&quot; &#125;,# 可参考文档 https://cli.vuejs.org/guide/cli-service.html 执行脚本12# 选择执行dev环境脚本npm run serve 调整webpack配置在根目录下新建文件vue.config.js文档参考 https://cli.vuejs.org/guide/webpack.html在根目录下新建.env .env.development .env.production文件，并修改启动脚本，实现加载不同环境下配置 vue.config.js参考配置1234567891011121314151617181920212223242526272829303132const path = require(&apos;path&apos;)const resolve = dir =&gt; &#123; return path.join(__dirname, dir)&#125;const BASE_URL = process.env.BASE_URL// 参见:https://cli.vuejs.org/guide/webpack.htmlmodule.exports = &#123; baseUrl: BASE_URL, // 根域上下文目录 outputDir: &apos;dist&apos;, // 构建输出目录 // assetsDir: &apos;assets&apos;, // 静态资源目录 (js, css, img, fonts) // pages: vueConf.pages, lintOnSave: true, // 是否开启eslint保存检测，有效值：ture | false | &apos;error&apos; runtimeCompiler: true, // 运行时版本是否需要编译 transpileDependencies: [], // 默认babel-loader忽略mode_modules，这里可增加例外的依赖包名 productionSourceMap: false, // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度 //加载器 chainWebpack: config =&gt; &#123; config.resolve.alias .set(&apos;@&apos;, resolve(&apos;src&apos;)) .set(&apos;_c&apos;, resolve(&apos;src/components&apos;)) &#125;, devServer: &#123; open: true, host: &apos;localhost&apos;, port: 8080, https: false, hotOnly: false, //代理 proxy: null, before: app =&gt; &#123;&#125; &#125;&#125; 添加其他组件1234567# 如安装包 @vue/cli-plugin-eslintvue add @vue/eslint# 如安装包 @foo/vue-cli-plugin-barvue add @foo/bar#安装vuex 和 vue-router是例外vue add routervue add vuex 常用组件1234567891011121314151617181920212223242526272829可发布生产(dependencies): vue // 包含vue-loader（必要组件） vue-router // vue 路由 （重要组件） vuex // 全局响应式状态仓库 （重要组件） axios // vue http请求 （重要组件） iview // iView UI框架 iview-area // 基于Iview的城市级联组件 clipboard // 轻量级的实现复制文本到剪贴板功能的JavaScript插件 codemirror // 文本编辑器插件 countup // 数字数据的动画 cropperjs //图像裁剪器。 echarts // 图表 html2canvas //浏览器截图插件 js-cookie // 轻量级的JavaScript API，用于处理cookie simplemde // Markdown编辑器 sortablejs // 重新排序的拖放列表的JavaScript库。 vue-i18n // vue国际化 wangeditor // 轻量级web富文本编辑器仅在开发环境(devDependencies): vue-template-compiler // vue-template组件（必要组件）,版本必须与vue保持一致 @vue/cli-plugin-babel // ES标准转换组件(必要组建) @vue/cli-service // cli-service服务，如运行 构建 测试(必要组件) less less-loader // less-loader(必要组件),将less编译为css,将css文件当做模块来处理 style标签里加上lang=”less”里面就可以写less的代码了style标签里加上scoped表示只在此作用域有效 @vue/cli-plugin-eslint @vue/eslint-config-standard // 语法检查 eslint-plugin-cypress lint-staged // 用于测试环境的语法检查插件 @vue/cli-plugin-unit-mocha // 使用mocha-webpack + chai运行单元测试。 @vue/test-utils // Vue.js的官方测试库。它提供了单元测试Vue组件的方法。 chai // Chai是节点和浏览器的BDD / TDD断言库，可以与任何javascript测试框架配对。 mockjs //模拟数据生成器，帮助前端开发和原型与后端进程分离，并在编写自动化测试时特别减少一些单调性。 执行脚本1234# 不是&apos;@vue/cli-plugin-&apos;开头的组件用以下安装方式npm install -save -dev @vue/eslint-config-standard vuex iview echarts mockjs# 是&apos;@vue/cli-plugin-【name】&apos;开头的组件可以以下方式安装vue add name 安装vue-ui12345Install:npm install -g @vue/cli# ORyarn global add @vue/cli Create a project:123vue create my-project# ORvue ui 安装过程1234567Vue CLI v3.0.5? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? (y/N) y 启动123yarn serve // ORnpm run serve 启动UI1vue ui 卸载重装123456$ sudo npm uninstall -g vue$ sudo npm uninstall -g vue-cli$ sudo npm uninstall -g @vue/cli$ sudo npm cache clean --force$ sudo npm install -g vue$ sudo npm install -g @vue/cli]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(二)：安装vue-cli]]></title>
    <url>%2F2018%2F10%2F24%2Fvue%E5%AE%89%E8%A3%85vue-cli%2F</url>
    <content type="text"><![CDATA[安装vue-cli假设你的机子上已经有了最新的node和npm了，那我们就只需要执行以下命令：1$ npm install -g vue-cli 构建完了之后，随便进入一个我们事先准备好的目录，比如demo目录，然后在目录中做初始化操作：1234# vue init 是vue初始化项目# webpack 是打包工具，其中也可以使用Browserify，感兴趣可以自行研究# project 是自定义的项目名称$ vue init webpack myProject webpack参数是指myProject这个项目将会在开发和完成阶段帮你自动打包代码，比如将js文件统一合成一个文件，将CSS文件统一合并压缩等。 安装中的提示信息,可以修改和选择12345678910? Project name vueproject ---------------------项目名称? Project description A Vue.js project---------------------项目描述? Author wondershoter &lt;starlord.yan@gmail.com&gt;---------------------作者? Vue build standalone? Install vue-router? Yes---------------------是否安装Vue路由，推荐安装，是页面跳转用的? Use ESLint to lint your code? Yes---------------------是否启用eslint检测规则? Set up unit tests no---------------------是否安装单元测试,选择否，不然安装依赖会卡住? Setup e2e tests with Nightwatch? Yes---------------------是否安装e2e测试? Should we run `npm install` for you after the project has been created? (recommended) npm 按照提示信息启动12345678# 进入工程目录cd myProject# 安装依赖，如果要具体安装其他模块可以单独使用，执行之后，目录里多了一个node_modules文件夹，这里放的就是所有依赖的模块npm install #如果安装过程已经执行，略过；# 运行项目npm run dev # 打包工作，用于正式环境npm run build npm run dev 是开始执行我们的项目了，一旦执行这个命令之后，等一小会，浏览器应该会自动帮你打开一个tab为http://localhost:8080/#/的链接，这个链接就是我们本地开发的项目主页 修改端口12345```## 文件目录分析package.json保存一些依赖信息，config保存一些项目初始化配置，build里面保存一些webpack的初始化配置，index.html是我们的首页，除了这些，最关键的代码都在src目录中，index在很多服务器语言中都是预设为首页，像index.htm，index.php等 build ——————-项目构建相关代码（webpack配置） build.js ————-生产环境构建代码 check-versions.js ———-检查node、npm等版本 utils.js ————————构建工具相关 vue-loader.conf.js ———css加载器的配置 webpack.base.conf.js —webpack的基础配置信息 webpack.dev.conf.js —–webpack开发环境配置信息，构建开发本地服务器 webpack.prod.conf.js —wenpack生产环境配置信息config ——————-配置目录，包括端口号，打包输出等的vue基本配置文件 dev.env.js ———–开发环境变量 prod.env.js ———–生产环境变量 index.js ————-项目的配置变量，端口号等node_modules ———–加载的项目依赖模块static ——————-静态资源目录index.html —————首页的入口文件，可以添加meta等参数README.md —————项目的说明文档，makedown格式src ———————–源码目录，主要的开发 assets —————静态资源，css,image等可以存放 components ———–公共组件 router —————路由文件夹，配置页面跳转 views —————-页面编写的地方，（可以自行定义命名）main.js ——————入口文件，全局的配置和加载.babelrc —————–ES6语法编译配置，用来将es6代码转换成浏览器可识别的es5代码.gitignore —————git上传需要忽略的文件的格式package.json ————-项目的基本信息，包括开发所需要的模块、项目名称、版本号等.postcssrc.js ————转换css的工具.editorconfig ————定义代码格式` 入口js文件在src目录中的main.js 说明Babel，转译成浏览器可识别的语言，可以让你的项目支持更新的语法，如es6\es7等PWA，模拟原生app，渐进式网络应用程序]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(九)：Hexo+Github+TravisCI部署到Github与自己的服务器]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%2BGithub%2BTravisCI%E9%83%A8%E7%BD%B2%E5%88%B0Github%E4%B8%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[自动部署使用hexo在github上搭blog最大的问题就是，每次提交都需要先hexo -g，然后再deploy生成的文件们，这样哪怕是改一个小的地方都需要重新编译全部blog，因此使用Travis来自动持续集成提交到github以后的操作，具体逻辑： 写完blog后，直接push到github的source分支，其它的就可以不用管了 由于我的.travis.yml配置文件里设置监听的就是source分支，所以会触发webhook Travis则会将该项目clone过去，然后按照.travis.yml的设置执行接下来的命令 执行完成后，再将编译好的文件们发送到自己的服务器，顺便push回master分支上来 这样就可以在blog.godi13.com和Godi13.github.io上都访问blog了 Github为了使travis能够将编译好的文件们push回github，我们需要生成token，步骤如下：1) 点击github右上方头像，然后点setting，或者https://github.com/settings/profile2) 点击Developer settings3) 进入Personal access tokens，点击Generate new token,为token起一个名字，勾选repo，然后点击生成,生成token以后，一定要复制好，因为只显示一次，如果丢失只能再次生成 Travis1) 使用github帐号登录Travis，右上方按钮点击同步项目，下方打开需要集成的项目，最后点击齿轮进入项目配置页面2) 勾选相应配置，然后往下移动页面到环境变量3) 在这里我将变量名称名为REPO_TOKEN，放上token，点击Add按钮 Terminal回到终端，进入blog所在的文件夹下，新建.travis.yml文件，并添加以下内容123456789101112131415161718192021222324252627282930313233343536# 使用语言language: node_js# node版本node_js: stable# 设置只监听哪个分支branches: only: - source# 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除cache: apt: true yarn: true directories: - node_modules# tarvis生命周期执行顺序详见官网文档before_install:- git config --global user.name &quot;Godi13&quot;- git config --global user.email &quot;mqzq9388@gmail.com&quot;# 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除- curl -o- -L https://yarnpkg.com/install.sh | bash- export PATH=$HOME/.yarn/bin:$PATH- npm install -g hexo-cliinstall:# 不用yarn的话这里改成 npm i 即可- yarnscript:- hexo clean- hexo generateafter_success:- cd ./public- git init- git add --all .- git commit -m &quot;Travis CI Auto Builder&quot;# 这里的 REPO_TOKEN 即之前在 travis 项目的环境变量里添加的- git push --quiet --force https://$REPO_TOKEN@github.com/Godi13/Godi13.github.io.git master 然后，准备push该项目到github，看下是否成功，如果是新项目可参照下面的git指令12345678git init# 添加自己的项目git remote add origin git@github.com:Godi13/Godi13.github.io.git# 新建并切换分支git checkout --orphan sourcegit add -Agit commit -m &quot;Travis CI&quot;git push 关于 –orphan 请参考如何建立一個沒有 Parent 的獨立 Git branch 如最终成功则会看到 服务器未完… 参考资料使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器Hexo作者的.travis.yml配置用 Travis CI 自動部署網站到 GitHub一点都不高大上，手把手教你使用Travis CI实现持续部署使用 Travis CI 自动更新 GitHub Pages使用Travis CI自动构建hexo博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(六)：绑定个人域名]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[绑定个人域名现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到GoDaddy官网，，也可以到阿里万网购买。 1.Github端在/blog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：victoryofymk.com写入。 终端cd到blog目录下执行如下命令重新部署： 123456$ hexo clean$ hexo g$ hexo d 注意：网上许多都是说在Github上直接新建CNAME文件，如果这样的话，在你下一次执行hexo d部署命令后CNAME文件就消失了，因为本地没有此文件。 2.域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –> 添加解析1234记录类型：CNAME主机记录：将域名解析为[example.com](https://link.jianshu.com/?t=http%253A%252F%252Fexample.com)（不带www），填写@或者不填写记录值：victoryofymk.github.io. (victoryofymk改为你自己的用户名)，点击保存即可域名解析 此时，点击访问http://victoryofymk.com和访问http://victoryofymk.github.io效果一致，大功告成！ 参考的文章： 1.http://gonghonglou.com/2016/02/03/firstblog/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(七)：第三方服务]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[评论系统为hexo增加评论功能 添加disqus评论使用该评论功能需要“科学上网”。 1.注册disqus账号https://disqus.com 2.在disqus设置页面中点 Add Disqus to your site 添加你的网站地址(即为https://yourname.github.io), 和设置Choose your unique Disqus URL, 你所填写的unique Disqus URL即为hexo配置文件中需要修改的short_name字段。 3.评论预审核可以不填写4.第一次需要验证邮箱5.打开hexo/themes/next/_config.yml主题配置文件，修改下面字段：12345#Disqusdisqus: enable: true shortname: #shortname即为你上面填写的唯一disqus路径，填上就好 count: true 添加Hypercomments来自俄罗斯,提供付费和免费的服务 添加Valine基于LeanCloud，也支持阅读量等，免费版有一定限制首先API请求每天30000，存储10G 修改next主题配置文件 1234567891011121314# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: false # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html appid,appkey 填写leancloud的应用注册后提供的即可，参考另一篇博客或者站内搜索 添加Gitment基于github的issue实现的,不再维护 添加Gitalk基于github的issue实现的,有人维护 登陆GitHub，然后点击头像，然后Settings，Developer settings,然后，点击OAuth Apps，New OAuth App创建12345参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://asdfv1929.github.ioApplication description # 描述，随意Authorization callback URL：# 网站URL，https://asdfv1929.github.io 创建完成后client id和client secret在配置文件中需要使用 修改next主题配置，新增 123456789101112# Gitalk评论gitalk: enable: true owner: #这个项目名的拥有者（GitHub账号或组织） repo: #你要存放的项目名 admin: #这个项目名的拥有者（GitHub账号或组织） labels: gitalk #GitHub issues的标签，下面会详细说 clientID: #client id clientSecret: #client secret gitalk_css: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css gitalk_js: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js # md5: //cdn.bootcss.com/blueimp-md5/1.1.0/js/md5.min.js gitalk.swig如果已经配置css和js可以省略，md5加密ID可以解决gitbub对Issue label长度最多50的限制。 另外可以参考next对于gitment等其他评论插件的集成。 配置主题方法一找到NexT的主题目录，然后进入这个路径/next/layout/_custom/下，应该有head.swig，header.swig，sidebar.swig这三个文件。这三个文件应该就是自定义布局的位置。然后，在sidebar.swig里面添加如下代码：12345678910111213141516171819202122232425&#123;% if page.comments and config.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; config.gitalk.gitalk_css &#125;&#125;&quot;&gt; &lt;script src=&quot;&#123;&#123; config.gitalk.gitalk_js &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;&#123;&#123; config.gitalk.md5 &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; config.gitalk.clientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; config.gitalk.clientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; config.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; config.gitalk.owner &#125;&#125;&apos;, admin: &apos;&#123;&#123; config.gitalk.admin &#125;&#125;&apos;, id: md5(location.pathname), distractionFreeMode: &apos;true&apos; &#125;); var div = document.createElement(&apos;div&apos;); div.setAttribute(&quot;id&quot;, &quot;gitalk_comments&quot;); div.setAttribute(&quot;class&quot;, &quot;post-nav&quot;); var bro = document.getElementById(&apos;posts&apos;).getElementsByTagName(&apos;article&apos;); bro = bro[0].getElementsByClassName(&apos;post-block&apos;); bro = bro[0].getElementsByTagName(&apos;footer&apos;); bro = bro[0]; bro.appendChild(div); gitalk.render(&apos;gitalk_comments&apos;); &lt;/script&gt;&#123;% endif %&#125; 参考：https://yunhao.space/2018/07/04/hexo-next-gitalk-comments-tutor/ 配置主题方法二以NexT主题做示范，毕竟其他的也是大同小异。在主题的\layout_third-party\comments目录中，新建一个gitalk.swig文件，文件内容如下：1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;&#123;&#123; theme.gitalk.md5 &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.admin &#125;&#125;&apos;], id: md5(location.pathname), distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 还是，在主题的\layout_third-party\comments目录中，找到一个index.swig的文件，打开，添加这一行代码：1&#123;% include &apos;gitalk.swig&apos; %&#125; 接着，在主题的\layout_partials目录中，找到comments.swig文件，打开，找到 12345&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/div&gt; &#123;% endif %&#125; 在空了一行的地方加上以下代码：12&#123;% elseif theme.gitalk.enable %&#125;&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： 1@import &quot;gitalk&quot;; 添加百度分享功能百度分享功能的添加可以参考下面这篇博客。Hexo+Github搭建个人博客(三)——百度分享集成 百度统计访客访问量功能其他酷炫小功能参考hexo的next主题个性化教程:打造炫酷网站。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK版本变化]]></title>
    <url>%2F2018%2F10%2F23%2FJDK%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[简介记录一下JDK版本的历史更新和重要特性。 目前JDK更新较快，每半年发布一个版本，但是对于生产环境采用仍然建议使用LTS(长期支持版本)版本 按照 Oracle 公布的支持路线图，Java 11 将会获得 Oracle 提供的长期支持服务，直至2026年9月。 根据官网从Java 11开始提供用开源许可证和商业许可证的组合 更新记录 2018-11-09 补充JDK8的介绍和使用 一些术语 JCP 是 Java Community Process（Java社区进程）的简称，社会各界Java组成的社区，规划和领导Java的发展。 JEP 是 JDK Enhancement Proposals （Java 增强提案）的简称，JDK的版本变化将从这些提案中选取。 JSR 是 Java Specification Requests（Java规范请求）的简称，是 JCP 成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过会成为 JEP，最终会体现在未来的Java中。 TCK 是 Technology Compatibility Kit（技术兼容性测试）的简称， 如果一个平台型程序想要宣称自己兼容Java，就必须通过TCK测试 JDK6 集合框架增强。 为了更好的支持双向访问集合。添加了许多新的类和接口。 新的数组拷贝方法。Arrays.copyOf和Arrays.copyOfRange 12//以下为添加的新接口和类Deque,BlockingDeque,NavigableSet,NavigableMap,ConcurrentNavigableMap，ArrayDeque， ConcurrentSkipListSet ,ConcurrentSkipListMap,ConcurrentSkipListMap ,AbstractMap.SimpleEntry ,AbstractMap.SimpleImmutableEntry Scripting. 可以让其他语言在java平台上运行。 java6包含了一个基于Mozilla Rhino实现的javascript脚本引擎。 支持JDBC4.0规范。 JDK7 二进制前缀0b或者0B。整型（byte, short, int, long）可以直接用二进制表示。 字面常量数字的下划线。用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾。 switch 支持String类型。 泛型实例化类型自动推断。 try-with-resources语句。 单个catch中捕获多个异常类型（用| 分割）并通过改进的类型检查重新抛出异常。 JDK8 Lambda 表达式(Lambda Expressions) − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。 方法引用（Method references） − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 （Default methods）− 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 java.util 包下的改进，提供了几个实用的工具类。并行数组排序。标准的Base64编解码。支持无符号运算。 java.util.concurrent 包下增加了新的类和方法。java.util.concurrent.ConcurrentHashMap 类添加了新的方法以支持新的StreamApi和lambada表达式。java.util.concurrent.atomic 包下新增了类以支持可伸缩可更新的变量。java.util.concurrent.ForkJoinPool类新增了方法以支持 common pool。新增了java.util.concurrent.locks.StampedLock类，为控制读/写访问提供了一个基于性能的锁，且有三种模式可供选择。 HotSpot删除了 永久代（PermGen）.方法调用的字节码指令支持默认方法。 重复注解（Repeating Annotations）。重复注解提供了在同一声明或类型中多次应用相同注解类型的能力。 类型注解（Type Annotation）。在任何地方都能使用注解，而不是在声明的地方。 类型推断增强 方法参数反射（Method Parameter Reflection）。 HashMap改进，在键值哈希冲突时能有更好表现。 部分特性说明： 1.Lambda 表达式Lambda 表达式，也可称为闭包，允许把函数作为一个方法的参数 语法lambda 表达式的语法格式如下：123(parameters) -&gt; expression或(parameters) -&gt;&#123; statements; &#125; 以下是lambda表达式的重要特征: 1234可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。可选的大括号：如果主体包含了一个语句，就不需要使用大括号。可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 Lambda 表达式实例 12345678910# 1. 不需要参数,返回值为 5 () -&gt; 5 # 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x # 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y # 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y # 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) 2.方法引用方法引用通过方法的名字来指向一个方法,可以使语言的构造更紧凑简洁，减少冗余代码。方法引用使用一对冒号 :: 语法构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：12final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car ); 静态方法引用：它的语法是Class::static_method，实例如下：1cars.forEach( Car::collide ); 特定类的任意对象的方法引用：它的语法是Class::method实例如下：1cars.forEach( Car::repair ); 特定对象的方法引用：它的语法是instance::method实例如下：12final Car police = Car.create( Car::new );cars.forEach( police::follow ); 方法引用实例 12345678910111213public class Java8Tester &#123; public static void main(String args[])&#123; List names = new ArrayList(); names.add(&quot;Google&quot;); names.add(&quot;Runoob&quot;); names.add(&quot;Taobao&quot;); names.add(&quot;Baidu&quot;); names.add(&quot;Sina&quot;); names.forEach(System.out::println); &#125;&#125; 函数式接口函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 函数式接口可以被隐式转换为 lambda 表达式。 如定义了一个函数式接口如下：12345@FunctionalInterfaceinterface GreetingService &#123; void sayMessage(String message);&#125; 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：1GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message); 默认方法Java 8 新增了接口的默认方法。简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个default关键字即可实现默认方法。 123为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。 语法默认方法语法格式如下： 12345public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;我是一辆车!&quot;); &#125;&#125; 多个默认方法一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法： 1234567891011public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;我是一辆车!&quot;); &#125;&#125; public interface FourWheeler &#123; default void print()&#123; System.out.println(&quot;我是一辆四轮车!&quot;); &#125;&#125; 第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法： 12345public class Car implements Vehicle, FourWheeler &#123; default void print()&#123; System.out.println(&quot;我是一辆四轮汽车!&quot;); &#125;&#125; 第二种解决方案可以使用 super 来调用指定接口的默认方法： 12345public class Car implements Vehicle, FourWheeler &#123; public void print()&#123; Vehicle.super.print(); &#125;&#125; 静态默认方法Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如： 123456789public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;我是一辆车!&quot;); &#125; // 静态方法 static void blowHorn()&#123; System.out.println(&quot;按喇叭!!!&quot;); &#125;&#125; StreamJava 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 123+--------------------+ +------+ +------+ +---+ +-------+| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|+--------------------+ +------+ +------+ +---+ +-------+ 以上的流程转换为 Java 代码为： 123456List&lt;Integer&gt; transactionsIds = widgets.stream() .filter(b -&gt; b.getColor() == RED) .sorted((x,y) -&gt; x.getWeight() - y.getWeight()) .mapToInt(Widget::getWeight) .sum(); 什么是 Stream？Stream（流）是一个来自数据源的元素队列并支持聚合操作 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。 生成流在 Java 8 中, 集合接口有两个方法来生成流： stream() − 为集合创建串行流。 parallelStream() − 为集合创建并行流。 12List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); forEachStream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数： 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); mapmap 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数： 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);// 获取对应的平方数List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList()); filterfilter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串： 123List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量int count = strings.stream().filter(string -&gt; string.isEmpty()).count(); limitlimit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据： 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); sortedsorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序： 12Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println); 并行（parallel）程序parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量： 123List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); 我们可以很容易的在顺序运行和并行直接切换。 CollectorsCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串： 123456List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选列表: &quot; + filtered);String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));System.out.println(&quot;合并字符串: &quot; + mergedString); 统计另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。 12345678List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());System.out.println(&quot;所有数之和 : &quot; + stats.getSum());System.out.println(&quot;平均数 : &quot; + stats.getAverage()); Optional 类Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 Optional 类的引入很好的解决空指针异常。 类声明以下是一个 java.util.Optional 类的声明： 12public final class Optional&lt;T&gt;extends Object Nashorn JavaScriptNashorn 一个 javascript 引擎。 从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。 与先前的Rhino实现相比，这带来了2到10倍的性能提升。 日期时间 APIava 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。 在旧版的 Java 中，日期时间 API 存在诸多问题，其中有： 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。 时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。 Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API： Local(本地) − 简化了日期时间的处理，没有时区的问题。 Zoned(时区) − 通过制定的时区处理日期时间。 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。 Base64在Java 8中，Base64编码已经成为Java类库的标准。 Java 8 内置了 Base64 编码的编码器和解码器。 Base64工具类提供了一套静态方法获取下面三种BASE64编解码器： 基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。 JDK9JDK 9 于2017年9月21日发布 新特性有： 模块化 —— Jigsaw（Java Platform Module System） 交互式命令行 —— JShell 进程操作改进 竞争锁的性能优化 分段代码缓存 优化字符串占用空间 Javadoc简化Doclet API。支持生成HTML5格式。加入了搜索框,使用这个搜索框可以查询程序元素、标记的单词和文档中的短语。支持新的模块系统。 JVM增强了Garbage-First(G1)并用它替代Parallel GC成为默认的垃圾收集器。统一了JVM 日志，为所有组件引入了同一个日志系统。删除了JDK 8中弃用的GC组合。（DefNew + CMS，ParNew + SerialOld，Incremental CMS）。 properties文件支持UTF-8编码,之前只支持ISO-8859-1。 支持Unicode 8.0，在JDK8中是Unicode 6.2。 支持私有接口方法(您可以使用diamond语法与匿名内部类结合使用)。 下划线不能用在变量名中。 diamond语法与匿名内部类结合使用。 新的版本号格式。$MAJOR.$MINOR.$SECURITY.$PATCH JDK10北京时间 3 月 21 日，Oracle 官方宣布 Java 10 正式发布。新特性有： JEP 286: 局部变量的类型推导。该特性在社区讨论了很久并做了调查，可查看 JEP 286 调查结果。 JEP 296: 将 JDK 的多个代码仓库合并到一个储存库中。 JEP 304: 垃圾收集器接口。通过引入一个干净的垃圾收集器（GC）接口，改善不同垃圾收集器的源码隔离性。 JEP 307: 向 G1 引入并行 Full GC。 JEP 310: 应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中。 JEP 312: 线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程。 JEP 313: 移除 Native-Header Generation Tool (javah) JEP 314: 额外的 Unicode 语言标签扩展。包括：cu (货币类型)、fw (每周第一天为星期几)、rg (区域覆盖)、tz (时区) 等。 JEP 316: 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆。 JEP 317: 基于 Java 的 JIT 编译器（试验版本）。 JEP 319: 根证书。开源 Java SE Root CA 程序中的根证书。 JEP 322: 基于时间的版本发布模式。“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug 。 部分特性说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351. var 类型推断。这个语言功能在其他一些语言 (C#、JavaScript) 和基于 JRE 的一些语言 (Scala 和 Kotlin) 中，早已被加入。在 Java 语言很早就在考虑，早在 2016 年正式提交了 JEP286 提议。后来举行了一次公开的开发者调查，获得最多建议的是采用类似 Scala 的方案，“同时使用 val 和 var”，约占一半；第二多的是“只使用 var”，约占四分之一。后来 Oracle 公司经过慎重考虑，采用了只使用 var 关键字的方案。有了这个功能，开发者在写这样的代码时：ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;()可以省去前面的类型声明，而只需要var list = new ArrayList&lt;String&gt;()编译器会自动推断出 list 变量的类型。对于链式表达式来说，也会很方便：var stream = blocks.stream(); ... int maxWeight = stream.filter(b -&gt; b.getColor() == BLUE) .mapToInt(Block::getWeight) .max();开发者无须声明并且 import 引入 Stream 类型，只用 stream 作为中间变量，用 var 关键字使得开发效率提升。不过 var 的使用有众多限制，包括不能用于推断方法参数类型，只能用于局部变量，如方法块中，而不能用于类变量的声明，等等。另外，我个人认为，对于开发者而言，变量类型明显的声明会提供更加全面的程序语言信息，对于理解并维护代码有很大的帮助。一旦 var 被广泛运用，开发者阅读三方代码而没有 IDE 的支持下，会对程序的流程执行理解造成一定的障碍。所以我建议尽量写清楚变量类型，程序的易读维护性有时更重要一些。2. 统一的 GC 接口在 JDK10 的代码中，路径为 openjdk/src/hotspot/share/gc/，各个 GC 实现共享依赖 shared 代码，GC 包括目前默认的 G1，也有经典的 Serial、Parallel、CMS 等 GC 实现。3. 应用程序类数据（AppCDS）共享CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS(Application Class-Data Sharing) 支持。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。我们可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。我在自己 PC 电脑上做以下应用启动实验。首先部署 wildfly 12 应用服务器，采用 JDK10 预览版作为 Java 环境。另外需要用到一个工具 cl4cds[1]，作用是把加载类的日志记录，转换为 AppCDS 可以识别的格式。A、安装好 wildfly 并部署一个应用，具有 Angularjs, rest, jpa 完整应用技术栈，预热后启动三次，并记录完成部署时间分别为 6716ms, 6702ms, 6613ms，平均时间为 6677ms。B、加入环境变量并启动，导出启动类日志export PREPEND_JAVA_OPTS=&quot;-Xlog:class+load=debug:file=/tmp/wildfly.classtrace&quot;C、使用 cl4cds 工具，生成 AppCDS 可以识别的 cls 格式/jdk-10/bin/java -cp src/classes/ io.simonis.cl4cds /tmp/wildfly.classtrace /tmp/wildfly.cls打开文件可以看到内容为：java/lang/Object id: 0x0000000100000eb0java/io/Serializable id: 0x0000000100001090java/lang/Comparable id: 0x0000000100001268java/lang/CharSequence id: 0x0000000100001440......org/hibernate/type/AssociationType id: 0x0000000100c61208 super: 0x0000000100000eb0 interfaces: 0x0000000100a00d10 source: /home/shihang/work/jboss/wildfly/dist/target/wildfly-12.0.0.Final/modules/system/layers/base/org/hibernate/main/hibernate-core-5.1.10.Final.jarorg/hibernate/type/AbstractType id: 0x0000000100c613e0 super: 0x0000000100000eb0 interfaces: 0x0000000100a00d10 source: /home/shihang/work/jboss/wildfly/dist/target/wildfly-12.0.0.Final/modules/system/layers/base/org/hibernate/main/hibernate-core-5.1.10.Final.jarorg/hibernate/type/AnyType id: 0x0000000100c61820 super: 0x0000000100c613e0 interfaces: 0x0000000100c61030 0x0000000100c61208 source: /home/shihang/work/jboss/wildfly/dist/target/wildfly-12.0.0.Final/modules/system/layers/base/org/hibernate/main/hibernate-core-5.1.10.Final.jar....这个文件用于标记类的加载信息。D、使用环境变量启动 wildfly，模拟启动过程并导出 jsa 文件，就是记录了启动时类的信息。export PREPEND_JAVA_OPTS=&quot;-Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=/tmp/wildfly.cls -XX:+UnlockDiagnosticVMOptions -XX:SharedArchiveFile=/tmp/wildfly.jsa&quot;查看产生的文件信息，jsa 文件有较大的体积。/opt/work/cl4cds$ ls -l /tmp/wildfly.*-rw-rw-r-- 1 shihang shihang 8413843 Mar 20 11:07 /tmp/wildfly.classtrace-rw-rw-r-- 1 shihang shihang 4132654 Mar 20 11:11 /tmp/wildfly.cls-r--r--r-- 1 shihang shihang 177659904 Mar 20 11:13 /tmp/wildfly.jsaE、使用 jsa 文件启动应用服务器export PREPEND_JAVA_OPTS=&quot;-Xshare:on -XX:+UseAppCDS -XX:+UnlockDiagnosticVMOptions -XX:SharedArchiveFile=/tmp/wildfly.jsa&quot;启动完毕后记录时长，三次分别是 5535ms, 5333ms, 5225ms，平均为 5364ms，相比之前的 6677ms 可以算出启动时间提升了 20% 左右。这个效率提升，对于云端应用部署很有价值。以上实验方法参考于技术博客 [2]。4. JEP314，使用附加的 Unicode 语言标记扩展。JDK10 对于 Unicode BCP 47 有了更多的支持，BCP 47 是 IETF 定义语言集的规范文档。使用扩展标记，可以更方便的获得所需要的语言地域环境。如 JDK10 加入的一个方法，java.time.format.DateTimeFormatter::localizedBy通过这个方法，可以采用某种数字样式，区域定义或者时区来获得时间信息所需的语言地域本地环境信息。附：从链接 [3] 可以看到 JDK10 所有的方法级别改动。5. 查看当前 JDK 管理根证书。自 JDK9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 OpenJDK9 中 cacerts 为空，这样就会给开发者带来很多不变。EP318 就是利用 Oracle 开源出 Oracle JavaSE 中的 cacerts 信息，在 OpenJDK 中提供一组默认的根证书颁发机构证书，目前有 80 条记录。/jdk-10/bin$ ./keytool -list -cacertsEnter keystore password: Keystore type: JKSKeystore provider: SUNYour keystore contains 80 entriesverisignclass2g2ca [jdk], Dec 2, 2017, trustedCertEntry, Certificate fingerprint (SHA-256): 3A:43:E2:20:FE:7F:3E:A9:65:3D:1E:21:74:2E:AC:2B:75:C2:0F:D8:98:03:05:BC:50:2C:AF:8C:2D:9B:41:A1...... JDK11JDK 11 总共包含 17 个新的 JEP ，分别为： 181: Nest-Based Access Control（基于嵌套的访问控制） 309: Dynamic Class-File Constants（动态类文件常量） 315: Improve Aarch64 Intrinsics（改进 Aarch64 Intrinsics） 318: Epsilon: A No-Op Garbage Collector（Epsilon — 一个无操作的垃圾收集器） 320: Remove the Java EE and CORBA Modules（删除 Java EE 和 CORBA 模块） 321: HTTP Client (Standard) 323: Local-Variable Syntax for Lambda Parameters（用于 Lambda 参数的局部变量语法） 324: Key Agreement with Curve25519 and Curve448（Curve25519 和 Curve448 算法的密钥协议） 327: Unicode 10 328: Flight Recorder 329: ChaCha20 and Poly1305 Cryptographic Algorithms（ChaCha20 和 Poly1305 加密算法） 330: Launch Single-File Source-Code Programs（启动单一文件的源代码程序） 331: Low-Overhead Heap Profiling（低开销的 Heap Profiling） 332: Transport Layer Security (TLS) 1.3（支持 TLS 1.3） 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) （可伸缩低延迟垃圾收集器） 335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎） 336: Deprecate the Pack200 Tools and API （弃用 Pack200 工具和 API） 支持Unicode 10.0,在jdk10中是8.0。标准化HTTP Client编译器线程的延迟分配。添加了新的命令-XX:+UseDynamicNumberOfCompilerThreads动态控制编译器线程的数量。新的垃圾收集器—ZGC。一种可伸缩的低延迟垃圾收集器(实验性)。Epsilon。一款新的实验性无操作垃圾收集器。Epsilon GC 只负责内存分配，不实现任何内存回收机制。这对于性能测试非常有用，可用于与其他GC对比成本和收益。Lambda参数的局部变量语法。java10中引入的var字段得到了增强，现在可以用在lambda表达式的声明中。如果lambda表达式的其中一个形式参数使用了var，那所有的参数都必须使用var。 JDK12参考资料1.JDK 版本变化2.Java 9 揭秘]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(五)：个性化 next theme]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E4%B8%AA%E6%80%A7%E5%8C%96next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[个性化主要有以下32种： • 在右上角或者左上角实现fork me on github • 添加RSS • 添加动态背景 • 实现点击出现桃心效果 • 修改文章内链接文本样式 • 修改文章底部的那个带#号的标签 • 在每篇文章末尾统一添加“本文结束”标记 • 修改作者头像并旋转 • 博文压缩 • 修改代码块自定义样式 • 侧边栏社交小图标设置 • 主页文章添加阴影效果 • 在网站底部加上访问量 • 添加热度 • 网站底部字数统计 • 添加 README.md 文件 • 设置网站的图标Favicon • 实现统计功能 • 添加顶部加载条 • 在文章底部增加版权信息 • 添加网易云跟帖(跟帖关闭，已失效，改为来必力) • 隐藏网页底部powered By Hexo / 强力驱动 • 修改网页底部的桃心 • 文章加密访问 • 添加jiathis分享 • 博文置顶 • 修改字体大小 • 修改打赏字体不闪动 • 自定义鼠标样式 • 为博客加上萌萌的宠物 • DaoVoice 在线联系 • 点击爆炸效果 下面介绍几种常见配置,其他请参考文末链接 1.在右上角或者左上角实现fork me on github点击这里https://blog.github.com/2008-12-19-github-ribbons/挑选自己喜欢的样式，并复制代码。 例如，我的代码：12&lt;a href=&quot;https://github.com/Ahaochan&quot; class=&quot;&quot; target=&quot;_blank&quot; title=&quot;我的Github&quot; aria-label=&quot;我的Github&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/a&gt; 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在的下面)，并把href改为你的github地址 2.添加RSS执行以下命令安装 RSS 插件: 1$ npm install hexo-generator-feed --save 编辑网站根目录下的 _config.yml，添加以下代码开启 123456789# RSS订阅支持plugin:- hexo-generator-feed# Feed Atomfeed:type: atompath: atom.xmllimit: 20 NexT 主题，默认就可以；其他主题请参考主题说明，配置完之后运行： 1$ hexo clean &amp;&amp; hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 3. 侧边栏社交小图标设置打开主题配置文件（_config.yml），配置social 12345678910111213141516171819202122social: #GitHub: https://github.com/yourname || github GitHub: https://github.com/victoryofymk || github #E-Mail: mailto:yourname@gmail.com || envelope E-Mail: mailto:starlord.yan@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false # Dependencies: exturl: true in Tags Settings section below. # To encrypt links above use https://www.base64encode.org # Example encoded link: `GitHub: aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ= || github` exturl: false 4. 添加热度5. 文章字数统计和阅读时间估计运行 1npm install hexo-symbols-count-time --save NexT 主题也对这个插件进行了集成，可以进行一些高级设置 12345678# 「在NexT配置文件里修改」symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 # Average Word Length wpm: 275 # Words Per Minute 6. 根据标签推荐相关文章运行 1npm install hexo-related-popular-posts --save NexT 主题集成了这个插件的配置 1234567891011121314# 「在NexT配置文件里修改」# Related popular posts# Dependencies: https://github.com/tea3/hexo-related-popular-postsrelated_posts: enable: true title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 5 #PPMixingRate: 0.0 #isDate: false #isImage: false #isExcerpt: false 7. 设置阅读访问量关于Hexo博客的文章阅读量设置问题，常见方案如下：1、不蒜子，仅局限于在文章页面显示阅读数，首页是不显示的。 打开主题配置文件（_config.yml）12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 2、LeanCloud打开LeanCloud官网，进入注册页面注册。完成邮箱激活后，点击头像，进入控制台页面，如下： 创建应用创建应用取名test 创建Class创建Class命名为Counter,ACL权限默认即可 Next主题配置基本配置编辑主题目录下的site_page/themes/next/_config.yml配置，修改配置如下： 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: xxx app_key: xxx 其中，app_id和app_key在设置–应用Key中获取 Web安全为了保证应用的统计计数功能仅应用于自己的博客系统，你可以在应用-&gt;设置-&gt;安全中心的Web安全域名中加入自己的博客域名，以保证数据的调用安全。 确认其他配置123themes\next\layout\_scripts\third-party\lean-analytics.swig # 确保该文件存在themes\next\layout\_macro\post.swig # 大约171行存在leancloud_visitors相关代码themes\next\layout\_layout.swig # 大约83行引用了lean-analytics.swig文件 问题报错：Cannot read property ‘enable_sync’ of undefined解决：在blog站点下的配置文件_config.yml添加以下代码 123456leancloud_counter_security: enable_sync: true app_id: rjEGiCa******-gzGzoHsz app_key: zWE2Bry******8HmPyTpBQa username: # Will be asked while deploying if is left blank password: # Recommmended to be left blank. Will be asked while deploying if is left blank 8. 添加sitemap和baidusitemap安装sitemap 1npm install hexo-generator-sitemap --save 安装baidusitemap 1npm install hexo-generator-baidu-sitemap --save 在博客目录的_config.yml中添加如下代码,并修改url字段的值，其值默认为http://yoursite.com 1234567# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlurl: https://victoryofymk.github.io 9.为博客加上萌萌的宠物安装：1npm install -save hexo-helper-live2d 请向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 然后hexo clean ，hexo g ，hexo d 就可以看到了。 10.开启动态背景安装 1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest 参考的文章： 1. https://segmentfault.com/a/1190000009544924]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE(一)：VUE简介]]></title>
    <url>%2F2018%2F10%2F23%2Fvue%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js。 MVVM模式下图不仅概括了MVVM模式（Model-View-ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。 当创建了ViewModel后，双向绑定是如何达成的呢？ 首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。 直接引用在工程中直接引用vue，后续介绍使用vue-cli搭建vue工程化 Hello World示例12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这是我们的View--&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这是我们的Model var exampleData = &#123; message: &apos;Hello World!&apos; &#125; // 创建一个 Vue 实例或 &quot;ViewModel&quot; // 它连接 View 与 Model new Vue(&#123; el: &apos;#app&apos;, data: exampleData &#125;) &lt;/script&gt;&lt;/html&gt; 使用Vue的过程就是定义MVVM各个组成部分的过程的过程。 定义View定义Model创建一个Vue实例或”ViewModel”，它用于连接View和Model在创建Vue实例时，需要传入一个选项对象，选项对象可以包含数据、挂载元素、方法、模生命周期钩子等等。 12在这个示例中，选项对象的el属性指向View，el: &apos;#app&apos;表示该Vue实例将挂载到&lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;这个元素；data属性指向Model，data: exampleData表示我们的Model是exampleData对象。Vue.js有多种数据绑定的语法，最基础的形式是文本插值，使用一对大括号语法，在运行时&#123;&#123; message &#125;&#125;会被数据对象的message属性替换，所以页面上会输出&quot;Hello World!&quot;。 双向绑定示例MVVM模式本身是实现了双向绑定的，在Vue.js中可以使用v-model指令在表单元素上创建双向数据绑定。123456&lt;!--这是我们的View--&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;&lt;/div&gt;将message绑定到文本框，当更改文本框的值时，&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; 中的内容也会被更新。反过来，如果改变message的值，文本框的值也会被更新，我们可以在Chrome控制台进行尝试。 Vue.js的常用指令Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）。123456v-if指令v-show指令v-else指令v-for指令v-bind指令v-on指令 v-if指令v-if是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：v-if=”expression”expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。例如： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt; &lt;h1 v-if=&quot;yes&quot;&gt;Yes!&lt;/h1&gt; &lt;h1 v-if=&quot;no&quot;&gt;No!&lt;/h1&gt; &lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt; &lt;h1 v-if=&quot;name.indexOf(&apos;jack&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; yes: true, no: false, age: 28, name: &apos;keepfool&apos; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 注意：yes, no, age, name这4个变量都来源于Vue实例选项对象的data属性。这段代码使用了4个表达式： 数据的yes属性为true，所以”Yes!”会被输出； 数据的no属性为false，所以”No!”不会被输出； 运算式age &gt;= 25返回true，所以”Age: 28”会被输出； 运算式name.indexOf(‘jack’) &gt;= 0返回false，所以”Name: keepfool”不会被输出。注意：v-if指令是根据条件表达式的值来执行元素的插入或者删除行为。 v-show指令v-show也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt; &lt;h1 v-show=&quot;yes&quot;&gt;Yes!&lt;/h1&gt; &lt;h1 v-show=&quot;no&quot;&gt;No!&lt;/h1&gt; &lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt; &lt;h1 v-show=&quot;name.indexOf(&apos;jack&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; yes: true, no: false, age: 28, name: &apos;keepfool&apos; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 在Chrome控制台更改age属性，使得表达式age &gt;= 25的值为false，可以看到Age: 24元素被设置了style=”display:none”样式。 v-else指令可以用v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt; &lt;h1 v-else&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;h1&gt;---------------------分割线---------------------&lt;/h1&gt; &lt;h1 v-show=&quot;name.indexOf(&apos;keep&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;h1 v-else&gt;Sex: &#123;&#123; sex &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; age: 28, name: &apos;keepfool&apos;, sex: &apos;Male&apos; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; v-else元素是否渲染在HTML中，取决于前面使用的是v-if还是v-show指令。这段代码中v-if为true，后面的v-else不会渲染到HTML；v-show为tue，但是后面的v-else仍然渲染到HTML了。 v-for指令v-for指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似： 1v-for=&quot;item in items&quot; items是一个数组，item是当前被遍历的数组元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/demo.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Sex&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;person in people&quot;&gt; &lt;td&gt;&#123;&#123; person.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; person.age &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; person.sex &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; people: [&#123; name: &apos;Jack&apos;, age: 30, sex: &apos;Male&apos; &#125;, &#123; name: &apos;Bill&apos;, age: 26, sex: &apos;Male&apos; &#125;, &#123; name: &apos;Tracy&apos;, age: 22, sex: &apos;Female&apos; &#125;, &#123; name: &apos;Chris&apos;, age: 36, sex: &apos;Male&apos; &#125;] &#125; &#125;) &lt;/script&gt;&lt;/html&gt; v-bind指v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class 1v-bind:argument=&quot;expression&quot; 下面这段代码构建了一个简单的分页条，v-bind指令作用于元素的class特性上。这个指令包含一个表达式，表达式的含义是：高亮当前页。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/demo.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li v-for=&quot;n in pageCount&quot;&gt; &lt;a href=&quot;javascripit:void(0)&quot; v-bind:class=&quot;activeNumber === n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; activeNumber: 1, pageCount: 10 &#125; &#125;) &lt;/script&gt;&lt;/html&gt; v-on指令v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听元素的点击事件： 1&lt;a v-on:click=&quot;doSomething&quot;&gt; 有两种形式调用方法：绑定一个方法（让事件指向方法的引用），或者使用内联语句。Greet按钮将它的单击事件直接绑定到greet()方法，而Hi按钮则是调用say()方法。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/p&gt; &lt;p&gt; &lt;!--click事件直接绑定一个方法--&gt; &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt; &lt;/p&gt; &lt;p&gt; &lt;!--click事件使用内联语句--&gt; &lt;button v-on:click=&quot;say(&apos;Hi&apos;)&quot;&gt;Hi&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello, Vue.js!&apos; &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function() &#123; // // 方法内 `this` 指向 vm alert(this.message) &#125;, say: function(msg) &#123; alert(msg) &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; v-bind和v-on的缩写Vue.js为最常用的两个指令v-bind和v-on提供了缩写方式。v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号。 123456789&lt;!--完整语法--&gt;&lt;a href=&quot;javascripit:void(0)&quot; v-bind:class=&quot;activeNumber === n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;&lt;!--缩写语法--&gt;&lt;a href=&quot;javascripit:void(0)&quot; :class=&quot;activeNumber=== n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;&lt;!--完整语法--&gt;&lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;!--缩写语法--&gt;&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(二)：关联 github]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E5%85%B3%E8%81%94github%2F</url>
    <content type="text"><![CDATA[创建仓库登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如victoryofymk.github.io 修改blog配置本地的blog文件夹下内容为：1234567_config.yml db.json node_modules package.jsonscaffoldssourcethemes 终端cd到blog文件夹下，vim打开_config.yml，命令如下：1$ vim _config.yml 打开后往下滑到最后，修改成下边的样子：1234deploy: type: git repository: https://github.com/victoryofymk/victoryofymk.github.io.git branch: master 将repository后victoryofymk换成你自己的用户名 注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即12Username for &apos;xxx&apos;:Password for &apos;xxx&apos;: hexo deploy命令执行成功后，浏览器中打开网址http://victoryofymk.github.io（将victoryofymk换成你的用户名）能看到和打开http://localhost:4000时一样的页面。 注意：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：1$ npm install hexo-deployer-git --save 再次执行hexo deploy命令。 未避免每次输入Github用户名和密码的麻烦，可参照下一节 添加ssh key到Github1.检查SSH keys是否存在Github执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤3将SSH key添加到Github中，否则进入下一步生成SSH key。1$ ls -al ~/.ssh 2.生成新的ssh key执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。3.将ssh key添加到Github中Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。1进入Github --&gt; Settings --&gt; SSH keys --&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 将个人博客同时部署到 GitHub 和 Coding1、首先到 Coding 上注册并开一个项目，项目名称和用户个性后缀相同（方便二级域名访问博客），拿到项目的 https 地址2、打开本地 blog 目录下的 _config.yml 文件，修改如下123456deploy: type: git repository: github: https://github.com/xxx/xxx.github.io.git coding: https://git.coding.net/xxx/xxx.git branch: master 3、cd 到本地 blog/source 目录下执行如下命令新建 Staticfile 文件1$ touch Staticfile #名字必须是Staticfile 原因是 coding.net 需要以这个文件来作为静态文件部署的标志，就是说看到这个 Staticfile 就知道按照静态文件来发布。4、执行发布命令1hexo g 、 hexo d 5、个人域名添加两条 CNAME 解析。将 xxx.github.io. 解析为 [海外] ，将 xxx.coding.me. 解析为 [默认]这样就是为了从国内访问 xxx.com 就是访问 Coding 上的博客项目，从国外访问 xxx.com 就是访问 GitHub 上的博客项目。6、到 Coding 上的博客项目主页，点击 Pages服务 输入部署分支 master 立即开启 这样就可以访问自己在 Coding 上的个人博客了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(三)：创建分类页面]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[创建分类添加一个 分类 页面，并在菜单中显示页面链接。 新建一个页面，命名为 categories 。命令如下： 1hexo new page categories 编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如： 12345title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false--- 在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories注释去掉，如下: 12345menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(一)：安装 hexo]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[常用依赖• Hexo - 快速、简洁且高效的博客框架• Github Pages - 完美的静态博客服务器（除大陆网速慢外）• NexT - 一款高质量且简洁优雅的Hexo主题• Travis CI - 一个持续集成测试工具 安装依赖搭建环境：macos 1.安装node1Brew install node 2.安装git1brew install git 3.安装 hexo1npm install -g hexo 初始化终端cd到一个你选定的目录，执行hexo init命令：1$ hexo init blog blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：1$ npm install 执行如下命令，开启hexo服务器：1$ hexo s 此时，浏览器中打开网址http://localhost:4000 基本操作终端cd到blog文件夹下，执行如下命令新建文章：12#名为postName.md的文件会建在目录/blog/source/_posts下hexo new &quot;postName&quot; 在blog文件夹目录下执行生成静态页面命令：1$ hexo generate 或者：hexo g 此时若出现如下报错：12ERROR Local hexo not found in ~/blogERROR Try runing: &apos;npm install hexo --save&apos; 则执行命令：1$ npm install hexo --save 若无报错，自行忽略此步骤。 重新部署hexo clean：清空publichexo g：静态文件重新生成hexo d：部署 hexo generate hexo deploy 简写 hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(四)：安装 theme next]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E5%AE%89%E8%A3%85next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装theme你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例 终端cd到 blog 目录下执行如下命令：1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 将blog目录下_config.yml里theme的名称landscape修改为next终端cd到blog目录下执行如下命令(每次部署文章的步骤)：123$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。 升级 nexT 主题，cd 到 blog/themes/next/ 下执行命令 git pull 更新 设置语言NexT 目前支持六种语言版本： • English • 中文简体 (zh-Hans) • French (fr-FR) • 正体中文 (zh-hk/zh-tw) • Russian (ru) • German (de)默认语言是英文。编辑站点的_config.yml，将language字段更改为你所需要的语言版本代号：language: default #默认是英文1234567language: zh-CNlanguage: fr-FRlanguage: zh-HKlanguage: zh-TWlanguage: enlanguage: rulanguage: de 设置文章目录Toc true设置归档]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(十)：使用中的问题]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常见问题Template render error解析异常，通常在hexo g的时候出现，通常是某些代码被解析 12Template render error: (unknown path) Error: template not found: ./comments/livere.swig 如果让jekyll不解析，使用raw语法，中间写内容 123456&#123;% raw %&#125;&#123;% sometag %&#125;&#123;% endraw %&#125; Found incompatible module使用yarn管理依赖 1error nunjucks@3.1.3: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;&gt;= 6.9.0 &lt;= 11.0.0-0&quot;. Got &quot;11.0.0&quot; 需要将node降级为7，在travis.yml中修改 12# node版本node_js: &quot;7&quot; gitalk授权问题使用github issue实现hexo评论功能，登陆时无法跳转到有效链接 解决办法：检查MD文件名称中是否有中文字符，例如：中文冒号：，如果有去掉即可，因为跳转时会转换成英文字符，所以路径就找不到，空格也可能有问题]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo(八)：添加其他功能]]></title>
    <url>%2F2018%2F10%2F23%2FHexo%E6%B7%BB%E5%8A%A0%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[为Hexo搜索与统计搜索与统计都比较简单，官方文档有详尽的明细,统计推荐不蒜子，简单粗暴。搜索的话我使用的是本地搜索，即Local Search。他的原理是在你本地生成一个xml文件,搜索的时候对这个文件进行检索。下面说说安装步骤1.执行下面2个命令12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 2.打开站点配置文件，新增以下内容：12345search: path: search.xml field: post format: html limit: 10000 3.打开主题配置文件，启用本地搜索功能：123# Local searchlocal_search: enable: true 图片先来看看hexo官方文档资源文件夹 设置好了以后每次你通过 hexo new blognames 在source文件夹下生成一个blognames.md文件以后会自动的生成一个文件夹,该文件夹也是以blognames命名,此时将你想要插入到md中的图片放进去,例如:我放了一个icon.jpg,name你就可以在md中这样引用了注意:按照官方的文档,引用的格式应该是:,其实不然,因为生成的相应的blognames博文和该资源位于同一个文件夹下,因此还是上面的引用方式是正确的]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx项目实践(四)]]></title>
    <url>%2F2017%2F09%2F19%2Fnginx%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5(%E5%9B%9B)%2F</url>
    <content type="text"></content>
      <categories>
        <category>nginx教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx编译部署(三)]]></title>
    <url>%2F2017%2F09%2F19%2Fnginx%E7%BC%96%E8%AF%91%E9%83%A8%E7%BD%B2(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[编译安装安装依赖 gzip模块需要 zlib 库,提供gzip压缩 rewrite模块需要 pcre 库， 提供地址重写 ssl 功能需要openssl库， 提供 ssl 功能 使用yum工具安装 gcc 编译器以及相关工具 使用yum工具安装 gcc 编译器以及相关工具 1yum -y install gcc gcc-c++ automake autoconf libtool make 安装zlib库1234567# 安装zlibcd /usr/local/src[root@localhost src]# wget http://zlib.net/zlib-1.2.8.tar.gz[root@localhost src]# tar xf zlib-1.2.8.tar.gz[root@localhost zlib-1.2.8]# cd zlib-1.2.8[root@localhost zlib-1.2.8]# ./configure[root@localhost zlib-1.2.8]# make &amp;&amp; make install 安装pcre库1234567# 安装pcrecd /usr/local/src[root@localhost src]# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.34.tar.gz[root@localhost src]# tar xf pcre-8.34.tar.gz[root@localhost pcre-8.34]# cd pcre-8.34[root@localhost pcre-8.34]# ./configure[root@localhost pcre-8.34]# make &amp;&amp; make install 安装openssl库1234# 安装sslcd /usr/local/src[root@localhost src]# wget http://www.openssl.org/source/openssl-1.0.1c.tar.gz[root@localhost src]# tar xf openssl-1.0.1c.tar.gz 安装nginx 编译选项： 对于很多场景都适用: –with-xxx 说明默认情况下是没有指定的。启用该功能。 –without-xxx 说明默认已经指定该选项。不启用该功能。 添加Nginx用户 123# 添加用户和组groupadd nginxuseradd -g nginx -s /sbin/nologin nginx 下载解压 12345# 指定目录解压 cd /usr/local/srcwget http://nginx.org/download/nginx-1.7.9.tar.gztar xf nginx-1.7.9.tar.gz cd nginx-1.7.9 隐藏 nginx 版本信息 123# 进入解压目录， 隐藏 nginx 版本信息# 就是说有些版本有漏洞，而有些版本没有。这样暴露出来的版本号就容易变成攻击者可利用的信息。所以，从安全的角度来说，隐藏版本号会相对安全些！sed -i -e &apos;s/1.7.9//g&apos; -e &apos;s/nginx\//TWS/g&apos; -e &apos;s/&quot;NGINX&quot;/&quot;TWS&quot;/g&apos; src/core/nginx.h 默认安装 12345678910111213141516# 可以按照默认选项./configure --prefix=/usr/local/nginx-1.7.9 \--with-http_ssl_module --with-http_spdy_module \--with-http_stub_status_module --with-pcre--with-http_stub_status_module：支持nginx状态查询--with-http_ssl_module：支持https--with-http_spdy_module：支持google的spdy,想了解请百度spdy,这个必须有ssl的支持 # 默认路径nginx path prefix: &quot;/usr/local/nginx-1.7.9&quot;nginx binary file: &quot;/usr/local/nginx-1.7.9/sbin/nginx&quot;nginx configuration prefix: &quot;/usr/local/nginx-1.7.9/conf&quot;nginx configuration file: &quot;/usr/local/nginx-1.7.9/conf/nginx.conf&quot;nginx pid file: &quot;/usr/local/nginx-1.7.9/logs/nginx.pid&quot;nginx error log file: &quot;/usr/local/nginx-1.7.9/logs/error.log&quot;nginx http access log file: &quot;/usr/local/nginx-1.7.9/logs/access.log&quot; 自定义安装 1234567891011121314# 也可以进行一些自定义./configure \--prefix=/usr/local/nginx \--conf-path=/etc/nginx/nginx.conf \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx/lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_ssl_module \--with-http_flv_module \--with-http_gzip_static_module \--with-http_stub_status_module \--user=nginx \--group=nginx 编译 1234567# make &amp;&amp; make install # 若安装时找不到上述依赖模块，使用--with-openssl=&lt;openssl_dir&gt;、--with-pcre=&lt;pcre_dir&gt;、--with-zlib=&lt;zlib_dir&gt;指定依赖的模块目录。 # 注意：如果是源码编译安装的第三方库, pcre, ssl, zlib等， 需要指定以下--with-pcre=/usr/local/src/pcre-8.34 # 指的是pcre-8.34 的源码路径--with-zlib=/usr/local/src/zlib-1.2.8 # 指的是zlib-1.2.7 的源码路径--with-openssl=/usr/local/src/openssl-1.0.1c # 指的是openssl-1.0.1c 的源码路径 其他模块安装Tcmalloc(google perfect tool)优化性能 TCMalloc(Thread-Caching Malloc)是google开发的开源工具─“google-perftools”中的成员。与标准的glibc库的malloc相比，TCMalloc在内存的分配上效率和速度要高得多。 安装Tcmalloc 12345678910111213141516171819202122# 下载解压wget http://download.savannah.gnu.org/releases/libunwind/libunwind-1.1.tar.gztar xf libunwind-1.1.tar.gz -C /usr/local/src cd /usr/local/src/libunwind-1.1/ CFLAGS=-fPIC ./configure make CFLAGS=-fPIC make CFLAGS=-fPIC install wget http://google-perftools.googlecode.com/files/google-perftools-1.9.tar.gz tar xf google-perftools-1.9.tar.gz -C /usr/local/src cd /usr/local/src/google-perftools-1.9/ ./configure make &amp;&amp; make install echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/usr_local_lib.conf /sbin/ldconfig# 编译nginx 加载google_perftools_module: ./configure --with-google_perftools_module # 在主配置文件加入nginx.conf 添加: google_perftools_profiles /path/to/profile; 重新编译安装 nginx 12345678910111213141516171819202122232425262728# 重新配置./configure --prefix=/usr/local/nginx \--with-http_ssl_module --with-http_spdy_module \--with-http_stub_status_module --with-pcre \--with-google_perftools_module# 重新编译make &amp;&amp; make install# 为 gperftools 创建线程目录mkdir /tmp/tcmalloc chmod 0777 /tmp/tcmalloc# 修改nginx的配置文件vi /usr/local/nginx/conf/nginx.conf # pid logs/nginx.pid; google_perftools_profiles /tmp/tcmalloc; # 添加这一行 # 启动nginx,并验证tcmalloc有没有正常加载# 安装一下lsof命令：yum install lsof -y/usr/local/nginx/sbin/nginxlsof -n |grep tcmalloc #每个线程（work_processes的值）会有一行记录，每个线程文件后面的数字值就是启动的nginx的pid值。 配置内核参数优化 在 /etc/sysctl.conf 末尾增加以下内容 12345678910111213141516171819202122# vi /etc/sysctl.conf net.ipv4.tcp_max_syn_backlog = 65536net.core.netdev_max_backlog = 32768net.core.somaxconn = 32768net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.tcp_timestamps = 0net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 300net.ipv4.tcp_syncookies = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_max_orphans = 3276800net.ipv4.ip_local_port_range = 1024 65535 # 使配置生效/sbin/sysctl -p nginx 可执行文件减肥 减小nginx编译后的文件大小 (Reduce file size of nginx) 默认的nginx编译选项里居然是用debug模式(-g)的（debug模式会插入很多跟踪和ASSERT之类），编译以后一个nginx有好几兆。去掉nginx的debug模式编译，编译以后只有几百K 12345678# 在nginx解压目录：vi auto/cc/gcc，最后几行有：debugCFLAGS=&quot;$CFLAGS -g&quot;注释掉或删掉这几行，重新编译即可。total 6.4M-rwxr-xr-x. 1 root root 804K Sep 30 15:58 nginx-rwxr-xr-x. 1 root root 5.6M Sep 30 15:36 nginx.old 启动、停止等命令命令行选项 不像许多其他开源软件，Nginx 仅有几个命令行参数，完全通过配置文件来配置，下面我们列举几个： 12345-c &lt;/path/to/config&gt; 为 Nginx 指定一个配置文件，来代替缺省的。-t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。-s 发送信号， 可以指定的信号[ stop, quit, reload, reopen]-v 显示 nginx 的版本。-V 显示 nginx 的版本，编译器版本和配置参数。 启动启动nginx 12345678910/usr/local/nginx/sbin/nginx# 可以使用参数 &quot;-c&quot; 指定配置文件的路径，否则加载默认配置/usr/local/nginx/sbin/nginx -c # netstat -tulpn | grep 80tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 9131/nginx # 测试curl -s http://localhost elinks -dump http://localhost 然后打开浏览器，访问此机器的IP，如果浏览器出现Welcome to nginx! 则表示Nginx已 经安装，并且已经成功启动，提供服务。 当然，如果开启iptables防火墙，我们要打开80端口： 123（1）iptables -I INPUT -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT（2）service iptables save （3）service iptables restart 停止nginx从容停止命令，等所有请求结束后关闭服务 1234567ps -ef | grep nginxkill -QUIT 【nginx主进程号】 (master process) # 在 nginx.conf配置文件中指定了pid文件存放路径，该文件中保存的就是当前nginx主进程号。默认是放在nginx安装目录的logs目录下，具体情况还得看编译选项。 kill -QUIT `cat /var/run/nginx/nginx.pid` 快速停止命令，立刻关闭nginx进程 1234ps -ef |grep nginxkill [-TERM | -INT] 【nginx主进程号】 # 如果以上命令不管用，可以强制停止所有nginx进程pkill -9 nginx 平滑重启 如果改变了 nginx 的配置文件，需要nginx 重新读取配置文件才能生效。同样可以发送系统信号给nginx主进程，不过，重启之前要确认 nginx 配置文件的语法是否正确。否则nginx将不会加载新的配置文件。可以通过下面的命令来判断配置文件是否正确： 12345678# -t 选项可以检查配置文件的语法是否正确。/usr/local/nginx/sbin/nginx -t # 如果要对指定的配置文件进行语法检查，同样可以添加 -c 选项/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf # 检查配置文件没有问题， 就可以平滑重启了。kill -HUP 【nginx 主进程号】 当nginx接收到 HUP 信号时，它会尝试先解析配置文件，如果成功，就应用新的配置文件（例如：重新打开日志文件或者监听的套接字）。之后，nginx运行新的work process并从容关闭旧的work process。通知work process关闭监听套接字，但是继续为当前已经连接的客户提供服务。所有的客户端服务完成后，旧的 work process 将被关闭。如果新的配置文件应用失败，nginx将继续使用旧的配置文件进行工作。 启动、关闭、重新加载配置 -s signal : send signal to a master process: stop, quit, reopen, reload 12345678# 启动/usr/local/nginx-1.7.9/sbin/nginx# 关闭/usr/local/nginx-1.7.9/sbin/nginx -s stop# 重新加载配置/usr/local/nginx-1.7.9/sbin/nginx -s reload 平滑升级 当需要将正在运行中的 nginx 升级、添加/删除服务器模块时，可以在不中断服务的情况下，使用新版本、重编译的 nginx 可执行程序替换旧版本的可执行程序。步骤如下： (1) 使用新的可执行程序替换旧的可执行程序，对于编译安装的 nginx，可以将新版本编译安装到旧版本的 nginx 安装路径中。替换之前，最好备份一下旧的可执行文件。 123456789101112131415161718191、获取旧版本的编译选项: /usr/local/nginx/sbin/nginx -V2、根据上述的编译选项，利用原来的编译选项进行编译新版本的 nginx ./configure [ 加上以前的编译选项 ]make # 这里不用在 make install3、备份旧版本的nginx可执行文件，复制新版本的nginx可执行文件： mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old4、复制编译后 objs 目录下的nginx文件到nginx的安装目录sbin/下cp objs/nginx /usr/local/nginx/sbin/nginx5、测试新版本的nginx配置文件/usr/local/nginx/sbin/nginx -t -c /etc/nginx/nginx.conf (2) 发送以下指令： 1kill -USR2 【旧版本的Nginx主进程号】 # `cat /var/run/nginx/nginx.pid` (3) 旧版本 nginx 的主进程将重命名它的 pid 文件为 .oldbin(例如：/var/run/nginx/nginx.pid.oldbin)，然后执行新版本的 nginx 可执行程序，依次启动新的主进程和新的工作进程。 1234root 23715 1 0 21:58 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxnginx 23716 23715 0 21:58 ? 00:00:00 nginx: worker process root 26066 23715 0 22:20 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginxnginx 26067 26066 0 22:20 ? 00:00:00 nginx: worker process (4) 此时，新、旧版本的 nginx 实例会同时运行，共同处理输入的请求。要逐步停止旧版本的 nginx 实例，你必须发送 WINCH 信号给旧的主进程，然后，它的工作进程就将开始从容关闭： 1kill -WINCH 【旧版本的Nginx主进程号】 # `cat /var/run/nginx/nginx.pid.oldbin` (5) 一段时间后，旧的工作进程(worker process)处理了所有已连接的请求后退出，仅由新的工作进程来处理输入的请求了。 (6) 这时候，我们可以决定是使用新版本，还是恢复到旧版本： 1234567891011kill -HUP 【旧的主进程号】：nginx 将在不重载配置文件的情况下启动它的工作进程 kill -QUIT 【新的主进程号】：从容关闭其工作进程(worker process) kill -TERM 【新的主进程号】：强制退出 kill 【新的主进程号或旧的主进程号】：如果因为某些原因新的工作进程不能退出，则向其发送 kill 信号 kill –HUP `cat /usr/local/nginx/logs/nginx.oldbin` ##nginx 将在不重载配置文件启动它的工作进程 kill –QUIT `cat /usr/local/nginx/logs/nginx.oldbin` ##关闭旧版nginx 新的主进程退出后，旧的主进程会移除 .oldbin 后缀，恢复为它 的 .pid 文件，这样，一切就恢复到升级之前了。如果尝试升级成功，而你也希望保留新的服务器时，可发送 QUIT 信号给旧的主进程，使其退出而只留下新的服务器运行。 加载动态模块 Nginx 1.9.11开始增加加载动态模块支持 12345678910111213# 官方支持9个动态模块编译，需要增加第三方模块，使用参数--add-dynamic-module=即可 tinywan@tinywan:~/nginx-1.12.0$ ./configure --help | grep dynamic--with-http_xslt_module=dynamic enable dynamic ngx_http_xslt_module--with-http_image_filter_module=dynamic enable dynamic ngx_http_image_filter_module--with-http_geoip_module=dynamic enable dynamic ngx_http_geoip_module--with-http_perl_module=dynamic enable dynamic ngx_http_perl_module--with-mail=dynamic enable dynamic POP3/IMAP4/SMTP proxy module--with-stream=dynamic enable dynamic TCP/UDP proxy module--with-stream_geoip_module=dynamic enable dynamic ngx_stream_geoip_module--add-dynamic-module=PATH enable dynamic external module--with-compat dynamic modules compatibility 动态模块语法：12345load_moduleDefault: —配置段: main说明：版本必须&gt;=1.9.11实例：load_module modules/ngx_mail_module.so; 编译安装 添加 1./configure --with-http_xslt_module=dynamic --with-stream=dynamic --add-dynamic-module=../nginx-rtmp-module 为动态模块增加了一个新的编译选项，使用 –add-dynamic-module 代替 –add-module，例如 1$ ./configure --add-dynamic-module=/opt/source/ngx_my_module/ 加载一个动态模块 模块可以使用新的 load_module 标识符载入到 NGINX 中，例如： 1load_module modules/ngx_my_module.so; 注意 有一个强限制：一次只能加载 128 个动态模块。 这是在 NGINX 源码的 NGX_MAX_DYNAMIC_MODULES 常量中定义的，可以通过修改此常量放宽限制。 查看编译生成的模块12345tinywan@tinywan:/usr/local/nginx/modules$ lsngx_http_xslt_filter_module.so ngx_rtmp_module.so ngx_stream_module.so或者nginx -V 配置文件 不加载模块配置文件nginx.conf 最末尾添加 12345678910111213141516171819202122232425262728293031323334worker_processes 1;load_module &quot;modules/ngx_rtmp_module.so&quot;;load_module &quot;modules/ngx_stream_module.so&quot;;events &#123; worker_connections 1024;&#125;stream &#123; upstream rtmp &#123; server 127.0.0.1:8089; # 这里配置成要访问的地址 server 127.0.0.2:1935; server 127.0.0.3:1935; #需要代理的端口，在这里我代理一一个RTMP模块的接口1935 &#125; server &#123; listen 1935; # 需要监听的端口 proxy_timeout 20s; proxy_pass rtmp; &#125;&#125;http &#123; include mime.types; ...&#125;rtmp &#123; server &#123; listen 1935; application mytv &#123; live on; &#125; &#125;&#125; 启动Nginx，提示错误,表示没有加载模块进去 安装编译选项说明指导说明Nginx安装编译选项说明 make是用来编译的，它从Makefile中读取指令，然后编译。 make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。 configure命令是用来检测你的安装平台的目标特征的。它定义了系统的各个方面，包括nginx的被允许使用的连接处理的方法，比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本，执行结束时，它会创建一个Makefile文件。nginx的configure命令支持以下参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187# 可以通过 ./configure --help 查看Nginx的编译选项。--prefix=path 定义一个目录，存放服务器上的文件 ，也就是nginx的安装目录。默认使用 /usr/local/nginx。--sbin-path=path 设置nginx的可执行文件的路径，默认为 prefix/sbin/nginx.--conf-path=path 设置在nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的 -c 选项。默认为prefix/conf/nginx.conf.--pid-path=path 设置nginx.pid文件，将存储的主进程的进程号。安装完成后，可以随时改变的文件名 ， 在nginx.conf配置文件中使用 PID指令。默认情况下，文件名 为prefix/logs/nginx.pid.--error-log-path=path 设置主错误，警告，和诊断文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的error_log指令。默认情况下，文件名 为prefix/logs/error.log.--http-log-path=path 设置主请求的HTTP服务器的日志文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的access_log指令。默认情况下，文件名 为prefix/logs/access.log.--user=name 设置nginx work process工作进程的用户。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的用户名是nobody。--group=name 设置nginx work process工作进程的用户组。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的为非特权用户。--with-select_module， --without-select_module 启用或禁用构建一个模块来允许服务器使用select()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。--with-poll_module， --without-poll_module 启用或禁用构建一个模块来允许服务器使用poll()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。--with-threads 启用线程池。--with-file-aio 启用file aio支持（一种APL文件传输格式）--with-ipv6 启用ipv6支持--with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）--with-http_spdy_module 启用ngx_http_spdy_module--with-http_realip_module 启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）--with-http_addition_module 启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）--with-http_xslt_module 启用ngx_http_xslt_module支持（过滤转换XML请求）--with-http_image_filter_module 启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）--with-http_geoip_module 启用ngx_http_geoip_module支持（该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量）--with-http_sub_module 启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）--with-http_dav_module 启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）默认情况下为关闭，需编译开启--with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）--with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）--with-http_random_index_module 启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）--with-http_secure_link_module 启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）--with-http_degradation_module 启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）--with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）--without-http_charset_module 禁用ngx_http_charset_module支持（重新编码web页面，但只能是一个方向--服务器端到客户端，并且只有一个字节的编码可以被重新编码）--without-http_gzip_module 禁用ngx_http_gzip_module支持（该模块同-with-http_gzip_static_module功能一样）--without-http_ssi_module 禁用ngx_http_ssi_module支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持SSI命令的列表是不完整的）--without-http_userid_module 禁用ngx_http_userid_module支持（该模块用来处理用来确定客户端后续请求的cookies）--without-http_access_module 禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于ip地址）--without-http_auth_basic_module禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法来保护你的站点或其部分内容）--without-http_autoindex_module 禁用disable ngx_http_autoindex_module支持（该模块用于自动生成目录列表，只在ngx_http_index_module模块未找到索引文件时发出请求。）--without-http_geo_module 禁用ngx_http_geo_module支持（创建一些变量，其值依赖于客户端的IP地址）--without-http_map_module 禁用ngx_http_map_module支持（使用任意的键/值对设置配置变量）--without-http_split_clients_module 禁用ngx_http_split_clients_module支持（该模块用来基于某些条件划分用户。条件如：ip地址、报头、cookies等等）--without-http_referer_module 禁用disable ngx_http_referer_module支持（该模块用来过滤请求，拒绝报头中Referer值不正确的请求）--without-http_rewrite_module 禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URI，并且根据变量来转向以及选择配置。如果在server级别设置该选项，那么他们将在 location之前生效。如果在location还有更进一步的重写规则，location部分的规则依然会被执行。如果这个URI重写是因为location部分的规则造成的，那么 location部分会再次被执行作为新的URI。 这个循环会执行10次，然后Nginx会返回一个500错误。）--without-http_proxy_module 禁用ngx_http_proxy_module支持（有关代理服务器）--without-http_fastcgi_module 禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。 ）FastCGI一个常驻型的公共网关接口。--without-http_uwsgi_module 禁用ngx_http_uwsgi_module支持（该模块用来医用uwsgi协议，uWSGI服务器相关）--without-http_scgi_module 禁用ngx_http_scgi_module支持（该模块用来启用SCGI协议支持，SCGI协议是CGI协议的替代。它是一种应用程序与HTTP服务接口标准。它有些像FastCGI但他的设计 更容易实现。）--without-http_memcached_module 禁用ngx_http_memcached_module支持（该模块用来提供简单的缓存，以提高系统效率）-without-http_limit_zone_module 禁用ngx_http_limit_zone_module支持（该模块可以针对条件，进行会话的并发连接数控制）--without-http_limit_req_module 禁用ngx_http_limit_req_module支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的session或一个特定的事件）--without-http_empty_gif_module 禁用ngx_http_empty_gif_module支持（该模块在内存中常驻了一个1*1的透明GIF图像，可以被非常快速的调用）--without-http_browser_module 禁用ngx_http_browser_module支持（该模块用来创建依赖于请求报头的值。如果浏览器为modern ，则$modern_browser等于modern_browser_value指令分配的值；如 果浏览器为old，则$ancient_browser等于 ancient_browser_value指令分配的值；如果浏览器为 MSIE中的任意版本，则 $msie等于1）--without-http_upstream_ip_hash_module 禁用ngx_http_upstream_ip_hash_module支持（该模块用于简单的负载均衡）--with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）--with-perl_modules_path= 设定perl模块路径--with-perl= 设定perl库文件路径--http-log-path= 设定access log路径--http-client-body-temp-path= 设定http客户端请求临时文件路径--http-proxy-temp-path= 设定http代理临时文件路径--http-fastcgi-temp-path= 设定http fastcgi临时文件路径--http-uwsgi-temp-path= 设定http uwsgi临时文件路径--http-scgi-temp-path= 设定http scgi临时文件路径-without-http 禁用http server功能--without-http-cache 禁用http cache功能--with-mail 启用POP3/IMAP4/SMTP代理模块支持--with-mail_ssl_module 启用ngx_mail_ssl_module支持--without-mail_pop3_module 禁用pop3协议（POP3即邮局协议的第3个版本,它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。是因特网电子邮件的第一个离线协议标 准,POP3协议允许用户从服务器上把邮件存储到本地主机上,同时根据客户端的操作删除或保存在邮件服务器上的邮件。POP3协议是TCP/IP协议族中的一员，主要用于 支持使用客户端远程管理在服务器上的电子邮件）--without-mail_imap_module 禁用imap协议（一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上， 使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。）--without-mail_smtp_module 禁用smtp协议（SMTP即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。）--with-google_perftools_module 启用ngx_google_perftools_module支持（调试用，剖析程序性能瓶颈）--with-cpp_test_module 启用ngx_cpp_test_module支持--add-module= 启用外部模块支持--with-cc= 指向C编译器路径--with-cpp= 指向C预处理路径--with-cc-opt= 设置C编译器参数（PCRE库，需要指定–with-cc-opt=”-I /usr/local/include”，如果使用select()函数则需要同时增加文件描述符数量，可以通过–with-cc- opt=”-D FD_SETSIZE=2048”指定。）--with-ld-opt= 设置连接文件参数。（PCRE库，需要指定–with-ld-opt=”-L /usr/local/lib”。）--with-cpu-opt= 指定编译的CPU，可用的值为: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64--without-pcre 禁用pcre库--with-pcre 启用pcre库--with-pcre= 指向pcre库文件目录--with-pcre-opt= 在编译时为pcre库设置附加参数--with-md5= 指向md5库文件目录（消息摘要算法第五版，用以提供消息的完整性保护）--with-md5-opt= 在编译时为md5库设置附加参数--with-md5-asm 使用md5汇编源--with-sha1= 指向sha1库目录（数字签名算法，主要用于数字签名）--with-sha1-opt= 在编译时为sha1库设置附加参数--with-sha1-asm 使用sha1汇编源--with-zlib= 指向zlib库目录--with-zlib-opt= 在编译时为zlib设置附加参数--with-zlib-asm= 为指定的CPU使用zlib汇编源进行优化，CPU类型为pentium, pentiumpro--with-libatomic 为原子内存的更新操作的实现提供一个架构--with-libatomic= 指向libatomic_ops安装目录--with-openssl= 指向openssl安装目录--with-openssl-opt 在编译时为openssl设置附加参数--with-debug 启用debug日志 典型实例(下面为了展示需要写在多行，执行时内容需要在同一行)1234567./configure \ --sbin-path=/usr/local/nginx/nginx \ --conf-path=/usr/local/nginx/nginx.conf \ --pid-path=/usr/local/nginx/nginx.pid \ --with-http_ssl_module \ --with-pcre=../pcre-4.4 \ --with-zlib=../zlib-1.1.3 安装过程中的常见错误1、make 出错123456789make: *** No rule to make target `build&apos;, needed by `default&apos;. Stop../configure: error: SSL modules require the OpenSSL library.You can either do not enable the modules, or install the OpenSSL libraryinto the system, or build the OpenSSL library statically from the sourcewith nginx by using --with-openssl= option.原因：缺少OpenSSL library# 解决办法:yum -y install opensll openssl-devel 2、启动nginx报错123# nginx: [emerg] getpwnam(“www”) failed 错误处理方法，原因: 启动nginx之前，需要添加nginx运行的用户和组groupadd nginxuseradd -g nginx -s /sbin/nologin nginx]]></content>
      <categories>
        <category>nginx教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx功能介绍(二)]]></title>
    <url>%2F2017%2F09%2F19%2Fnginx%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[反向代理在客户端和服务器中间加上nginx服务器，由nginx去转发客户端的请求，避免直接暴露服务器，通常在应用需要部署到核心区时，通过DMZ区的nginx代理。 配置 server { listen 80; #监听端口 location / { proxy_pass http://192.168.1.2:8080; # 应用服务器HTTP地址 } } 正向代理服务器访问外部接口，如短信网关、邮件服务器等使用nginx转发请求 配置 server { resolver 192.168.1.1; #指定DNS服务器IP地址 listen 8080; location /sendSms { proxy_pass http://$http_host$request_uri; #设定代理服务器的协议和地址,域名需要DNS服务器 } } 如果是https代理，需要安装–with-http_ssl_module模块 server { resolver 192.168.1.1; #指定DNS服务器IP地址 listen 8080; location /sendSms { proxy_pass http://$http_host$request_uri; #设定代理服务器的协议和地址,域名需要DNS服务器 } } 如果无法使用dns服务器可以用hosts指向IP地址 负载均衡通过反向代理实现负载均衡，单机不能满足用户需求时，可以使用nginx将不同的请求转发给不同的服务器。 配置 upstream backend { server 192.168.1.1:80; # 应用服务器1 server 192.168.1.2:80; # 应用服务器2 } server { listen 80; location / { proxy_pass http://backend; } } 上面采用的是轮询分配至机制，意味着同一个用户的多次请求会随机发到不同的服务器，可以通过ip-hash，可以根据客户端ip将请求分配给一个固定的服务器处理。 配置 upstream backend { ip_hash; # 根据客户端IP地址Hash值将请求分配给固定的一个服务器处理 server 192.168.1.1:80; # 应用服务器1 server 192.168.1.2:80; # 应用服务器2 } server { listen 80; location / { proxy_pass http://backend; } } 如果机器配置不同，可以设置权重，根据各自性能配置不同访问量。 配置 upstream backend { ip_hash; # 根据客户端IP地址Hash值将请求分配给固定的一个服务器处理 server 192.168.1.1:80 weight 3; # 应用服务器1 ，处理3/4的请求 server 192.168.1.2:80 weight 1; # 应用服务器2 ，处理1/4的请求 } server { listen 80; location / { proxy_pass http://backend; } } 静态HTTP服务器将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。 配置 server { listen 80; # 端口号 location / { root /usr/share/nginx/html; # 静态文件路径 } } 虚拟主机多个应用部署在同一台服务器上，两个域名对应同一台服务器上，互不影响，如同两个服务器。 配置 server { listen 80 default_server; server_name _; return 444; # 过滤其他域名的请求，返回444状态码 } server { listen 80; server_name www.aaa.com; # www.aaa.com域名 location / { proxy_pass http://192.168.1.1:8080; # 对应端口号8080 } } server { listen 80; server_name www.bbb.com; # www.bbb.com域名 location / { proxy_pass http://192.168.1.1:8081; # 对应端口号8081 } } FastCGINginx本身不支持PHP等语言，但是它可以通过FastCGI来将请求扔给某些语言或框架处理（例如PHP、Python、Perl） 配置 server { listen 80; location ~ \.php$ { include fastcgi_params; fastcgi_param SCRIPT_FILENAME /PHP文件路径$fastcgi_script_name; # PHP文件路径 fastcgi_pass127.0.0.1:9000; # PHP-FPM地址和端口号 # 另一种方式：fastcgi_pass unix:/var/run/php5-fpm.sock; } }]]></content>
      <categories>
        <category>nginx教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>代理</tag>
      </tags>
  </entry>
</search>
