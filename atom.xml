<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>执行者的博客</title>
  
  <subtitle>云淡风轻</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://victoryofymk.github.io/"/>
  <updated>2018-11-14T06:37:06.755Z</updated>
  <id>https://victoryofymk.github.io/</id>
  
  <author>
    <name>执行者</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx简介(一)</title>
    <link href="https://victoryofymk.github.io/2018/11/14/nginx%E7%AE%80%E4%BB%8B(%E4%B8%80)/"/>
    <id>https://victoryofymk.github.io/2018/11/14/nginx简介(一)/</id>
    <published>2018-11-14T06:37:06.755Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h2><p>之前，nginx 默认支持http，如果要转发tcp需要安装第三方模块，在1.9.0之后的版本增加了stream模块用于一般的TCP代理和负载均衡。</p><pre><code>The ngx_stream_core_module module is available since version 1.9.0. This module is not built by default, it should be enabled with the --with-stream configuration parameter.ngx_stream_core_module 。</code></pre><p>这个模块在1.90版本后将被启用。但是并不会默认安装，需要在编译时通过指定 –with-stream 参数来激活这个模块。所以，我们如果需要用到这个功能，就需要加上 –with-stream 参数重新编译nginx。对于已在线上运行的nginx，你可能要用到平滑升级来避免线上的服务被中断，可以参考网上教程。</p><p>–with-http_ssl_module 模块支持https，默认没有安装，需要对原有的nginx进行平滑升级，同时需要一些其他配置库，对现有的nginx配置可以使用 nginx -V查询</p><pre><code>nginx version: nginx/1.10.2built by clang 8.0.0 (clang-800.0.42.1)built with OpenSSL 1.1.0c  10 Nov 2016 (running with OpenSSL 1.1.0f  25 May 2017)TLS SNI support enabledconfigure arguments: --prefix=/usr/local/Cellar/nginx/1.10.2_1 --with-http_ssl_module --with-pcre --sbin-path=/usr/local/Cellar/nginx/1.10.2_1/bin/nginx --with-cc-opt=&apos;-I/usr/local/opt/pcre/include -I/usr/local/opt/openssl@1.1/include&apos; --with-ld-opt=&apos;-L/usr/local/opt/pcre/lib -L/usr/local/opt/openssl@1.1/lib&apos; --conf-path=/usr/local/etc/nginx/nginx.conf --pid-path=/usr/local/var/run/nginx.pid --lock-path=/usr/local/var/run/nginx.lock --http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp --http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp --http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp --http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp --http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp --http-log-path=/usr/local/var/log/nginx/access.log --error-log-path=/usr/local/var/log/nginx/error.log --with-http_gzip_static_module --with-ipv6</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;版本更新&quot;&gt;&lt;a href=&quot;#版本更新&quot; class=&quot;headerlink&quot; title=&quot;版本更新&quot;&gt;&lt;/a&gt;版本更新&lt;/h2&gt;&lt;p&gt;之前，nginx 默认支持http，如果要转发tcp需要安装第三方模块，在1.9.0之后的版本增加了stream模块用于一般
      
    
    </summary>
    
      <category term="nginx教程" scheme="https://victoryofymk.github.io/categories/nginx%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="nginx" scheme="https://victoryofymk.github.io/tags/nginx/"/>
    
      <category term="代理" scheme="https://victoryofymk.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>VUE(七)：vue使用中的问题</title>
    <link href="https://victoryofymk.github.io/2018/10/29/vue%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://victoryofymk.github.io/2018/10/29/vue使用中的问题/</id>
    <published>2018-10-29T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="i-table的render方法this指向window"><a href="#i-table的render方法this指向window" class="headerlink" title="i-table的render方法this指向window"></a>i-table的render方法this指向window</h3><p>i-table 中render渲染的方法this指向window</p><p>解决办法:定义VUE时使用变量接收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let vue=new VUE（｛｝）</span><br></pre></td></tr></table></figure></p><h3 id="淘宝镜像"><a href="#淘宝镜像" class="headerlink" title="淘宝镜像"></a>淘宝镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR command failed: npm install --loglevel error --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure><p>编辑.vuerc，修改配置”useTaobaoRegistry”: false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.vuerc</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;h3 id=&quot;i-table的render方法this指向window&quot;&gt;&lt;a href=&quot;#i-table的render方法t
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>VUE(六)：vue-resource HTTP介绍</title>
    <link href="https://victoryofymk.github.io/2018/10/28/vue-resource%E4%BB%8B%E7%BB%8D/"/>
    <id>https://victoryofymk.github.io/2018/10/28/vue-resource介绍/</id>
    <published>2018-10-28T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>可以使用全局的 Vue.http 或者在 Vue 实例中的 this.$http 调用 http 服务。</p><p>使用<br>Vue 实例提供了 this.$http 服务可用于发送 HTTP 请求。 A request method call returns a Promise that resolves to the response. Vue 实例在所有回调方法中都会自动绑定到 this 里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // GET /someUrl</span><br><span class="line">  this.$http.get(&apos;/someUrl&apos;).then((response) =&gt; &#123;</span><br><span class="line">    // success callback</span><br><span class="line">  &#125;, (response) =&gt; &#123;</span><br><span class="line">    // error callback</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法<br>所有的请求类型都可以使用短函数，可以在全局或者 Vue 实例中使用。</p><p>// 全局 Vue 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line">Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure></p><p>// Vue 实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line">this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure></p><p>短方法清单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get(url, [options])</span><br><span class="line">head(url, [options])</span><br><span class="line">delete(url, [options])</span><br><span class="line">jsonp(url, [options])</span><br><span class="line">post(url, [body], [options])</span><br><span class="line">put(url, [body], [options])</span><br><span class="line">patch(url, [body], [options])</span><br></pre></td></tr></table></figure></p><p>选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">参数类型描述</span><br><span class="line">urlstring请求发送到的 URL</span><br><span class="line">bodyObject, FormData,  string请求中要发送的数据</span><br><span class="line">headersObject作为 HTTP 请求头发送的 Headers 对象</span><br><span class="line">paramsObject作为 URL 参数发送的 Parameters 对象</span><br><span class="line">methodstringHTTP 方法 (例如： GET, POST, ...)</span><br><span class="line">timeoutnumber请求超时的毫秒数 (0 为不超时)</span><br><span class="line">beforefunction(request)在请求发送之前用于修改请求选项的回调函数</span><br><span class="line">progressfunction(event)上传时用于控制 ProgressEvent 的回调函数</span><br><span class="line">credentialsbooleanIndicates whether or not cross-site Access-Control requests should be made using credentials</span><br><span class="line">emulateHTTPboolean使用 HTTP POST 发送 PUT, PATCH 和 DELETE 请求并设置 X-HTTP-Method-Override 头</span><br><span class="line">emulateJSONboolean以 application/x-www-form-urlencoded 内容类型发送请求报文</span><br></pre></td></tr></table></figure></p><p>响应<br>通过下面的属性和函数将请求解析为响应对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">属性类型描述</span><br><span class="line">urlstring响应的源 URL</span><br><span class="line">bodyObject, Blob, string响应的数据报文</span><br><span class="line">headersHeader响应头对象</span><br><span class="line">okboolean从 200 到 299 的 HTTP 状态码</span><br><span class="line">statusnumber响应中的 HTTP 状态码</span><br><span class="line">statusTextstring响应中的 HTTP 状态文本</span><br><span class="line">函数类型描述</span><br><span class="line">text()Promise作为字符串解析报文</span><br><span class="line">json()Promise作为 Json 对象解析报文</span><br><span class="line">blob()Promise作为 Blob 对象解析报文</span><br></pre></td></tr></table></figure></p><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // POST /someUrl</span><br><span class="line">  this.$http.post(&apos;/someUrl&apos;, &#123;foo: &apos;bar&apos;&#125;).then((response) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // get status</span><br><span class="line">    response.status;</span><br><span class="line"></span><br><span class="line">    // get status text</span><br><span class="line">    response.statusText;</span><br><span class="line"></span><br><span class="line">    // get &apos;Expires&apos; header</span><br><span class="line">    response.headers.get(&apos;Expires&apos;);</span><br><span class="line"></span><br><span class="line">    // set data on vm</span><br><span class="line">    this.$set(&apos;someData&apos;, response.body);</span><br><span class="line"></span><br><span class="line">  &#125;, (response) =&gt; &#123;</span><br><span class="line">    // error callback</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取图像并使用 blob() 方法来从响应中提取图像正文内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // GET /image.jpg</span><br><span class="line">  this.$http.get(&apos;/image.jpg&apos;).then((response) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // resolve to Blob</span><br><span class="line">    return response.blob();</span><br><span class="line"></span><br><span class="line">  &#125;).then(blob) =&gt; &#123;</span><br><span class="line">    // use image Blob</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拦截器<br>可以全局定义一个拦截器，用于预处理和后处理的请求。</p><p>请求处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.interceptors.push((request, next) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // modify request</span><br><span class="line">  request.method = &apos;POST&apos;;</span><br><span class="line"></span><br><span class="line">  // continue to next interceptor</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">请求和响应处理</span><br><span class="line">Vue.http.interceptors.push((request, next)  =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // modify request</span><br><span class="line">  request.method = &apos;POST&apos;;</span><br><span class="line"></span><br><span class="line">  // continue to next interceptor</span><br><span class="line">  next((response) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // modify response</span><br><span class="line">    response.body = &apos;...&apos;;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>返回一个响应并停止处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.interceptors.push((request, next) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // modify request ...</span><br><span class="line"></span><br><span class="line">  // stop and return response</span><br><span class="line">  next(request.respondWith(body, &#123;</span><br><span class="line">    status: 404,</span><br><span class="line">    statusText: &apos;Not found&apos;</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;可以使用全局的 Vue.http 或者在 Vue 实例中的 this.$http 调用 http 服务。&lt;/p&gt;
&lt;p&gt;使用
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>VUE(五)：vue-cli 3.0使用教程</title>
    <link href="https://victoryofymk.github.io/2018/10/27/vue-cli3.0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://victoryofymk.github.io/2018/10/27/vue-cli3.0使用教程/</id>
    <published>2018-10-27T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>路径别名，@ 等价于 /src 这个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Hello from &apos;@/components/Hello&apos;</span><br></pre></td></tr></table></figure></p><h3 id="vue-cli-3-0配置webpack"><a href="#vue-cli-3-0配置webpack" class="headerlink" title="vue-cli 3.0配置webpack"></a>vue-cli 3.0配置webpack</h3><p>vue-cli提供的是3.0.0-beta.6版本，简化成使用vue.config.js来配置项目</p><p>在根目录新建vue.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">    return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    lintOnSave: true,</span><br><span class="line">    chainWebpack: (config)=&gt;&#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(&apos;@$&apos;, resolve(&apos;src&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js 配置说明</span><br><span class="line">//官方vue.config.js 参考文档 https://cli.vuejs.org/zh/config/#css-loaderoptions</span><br><span class="line">// 这里只列一部分，具体配置参考文档</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 部署生产环境和开发环境下的URL。</span><br><span class="line">  // 默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上</span><br><span class="line">  //例如 https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/，则设置 baseUrl 为 /my-app/。</span><br><span class="line">  baseUrl: process.env.NODE_ENV === &quot;production&quot; ? &quot;./&quot; : &quot;/&quot;,</span><br><span class="line"> </span><br><span class="line">  // outputDir: 在npm run build 或 yarn build 时 ，生成文件的目录名称（要和baseUrl的生产环境路径一致）</span><br><span class="line">  outputDir: &quot;mycli3&quot;,</span><br><span class="line">  //用于放置生成的静态资源 (js、css、img、fonts) 的；（项目打包之后，静态资源会放在这个文件夹下）</span><br><span class="line">  assetsDir: &quot;assets&quot;,</span><br><span class="line">  //指定生成的 index.html 的输出路径  (打包之后，改变系统默认的index.html的文件名)</span><br><span class="line">  // indexPath: &quot;myIndex.html&quot;,</span><br><span class="line">  //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变)</span><br><span class="line">  filenameHashing: false,</span><br><span class="line"> </span><br><span class="line">  //   lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint</span><br><span class="line">  lintOnSave: true,</span><br><span class="line">  //如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置</span><br><span class="line">  // lintOnSave: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class="line"> </span><br><span class="line">  //是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。(默认false)</span><br><span class="line">  // runtimeCompiler: false,</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。</span><br><span class="line">   *  打包之后发现map文件过大，项目文件体积很大，设置为false就可以不输出map文件</span><br><span class="line">   *  map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。</span><br><span class="line">   *  有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。</span><br><span class="line">   * */</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line"> </span><br><span class="line">  // 它支持webPack-dev-server的所有选项</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: &quot;localhost&quot;,</span><br><span class="line">    port: 1111, // 端口号</span><br><span class="line">    https: false, // https:&#123;type:Boolean&#125;</span><br><span class="line">    open: true, //配置自动启动浏览器</span><br><span class="line">    // proxy: &apos;http://localhost:4000&apos; // 配置跨域处理,只有一个代理</span><br><span class="line"> </span><br><span class="line">    // 配置多个代理</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &quot;/api&quot;: &#123;</span><br><span class="line">        target: &quot;&lt;url&gt;&quot;,</span><br><span class="line">        ws: true,</span><br><span class="line">        changeOrigin: true</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;/foo&quot;: &#123;</span><br><span class="line">        target: &quot;&lt;other_url&gt;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>import默认会找该目录下index.js的文件，新增一个组件可以创建一个目录name,在里面创建index.js<br>导入使用如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./name&apos;</span><br></pre></td></tr></table></figure></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>钩子：<br>常用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Created：vue实例被生成后的一个生命周期钩子函数。(页面初始化数据加载一般写这里);</span><br><span class="line">beforeCreate：给个loading界面 created撤销loading;</span><br><span class="line">beforeDestory：你确认删除XX吗？</span><br><span class="line">destoryed：当前组件已被删除，清空相关内容</span><br></pre></td></tr></table></figure></p><p>vue组件的声明周期</p><h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><p>npm install node-sass –save-dev<br>npm install sass-loader –save-dev</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h2&gt;&lt;p&gt;路径别名，@ 等价于 /src 这个目录&lt;br&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>VUE(四)：引入iview</title>
    <link href="https://victoryofymk.github.io/2018/10/26/vue%E5%BC%95%E5%85%A5iview/"/>
    <id>https://victoryofymk.github.io/2018/10/26/vue引入iview/</id>
    <published>2018-10-26T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境基础"><a href="#环境基础" class="headerlink" title="环境基础"></a>环境基础</h2><p>vue-cli 3.x搭建环境</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><p>NPM安装 iView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S iview</span><br></pre></td></tr></table></figure></p><h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><p>一般在 webpack 入口页面 main.js 中如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import iView from &apos;iview&apos;;</span><br><span class="line">import &apos;iview/dist/styles/iview.css&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(iView);</span><br></pre></td></tr></table></figure></p><p>會出現 iView is unidefined,正確的配置<br>src/iview/index.js</p><p>import iview from ‘iview’<br>前面的 iview 要用小寫<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import iview from &quot;iview&quot;;</span><br><span class="line">import &quot;iview/dist/styles/iview.css&quot;;</span><br><span class="line"></span><br><span class="line">Vue.use(iview);</span><br></pre></td></tr></table></figure></p><p>src/main.js加入這一行即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./iview&quot;;</span><br></pre></td></tr></table></figure></p><p>注意：babel.config.js中的plugins配置要删除，否则会引起冲突</p><h4 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h4><p>修改babel.config.js，添加下面配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;import&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;iview&quot;,</span><br><span class="line">        &quot;libraryDirectory&quot;: &quot;src/components&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>如果您想在 webpack 中按需使用组件，减少文件体积，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Button, Table &#125; from &apos;iview&apos;;</span><br><span class="line">Vue.component(&apos;Button&apos;, Button);</span><br><span class="line">Vue.component(&apos;Table&apos;, Table);</span><br></pre></td></tr></table></figure></p><p><strong>提醒：*</strong>按需引用仍然需要导入样式，即在 main.js<br>或根组件执行 import ‘iview/dist/styles/iview.css’;*</p><p>注意：尽量使用index.js中的命名，避免使用vue内置的名字，否则会引起错误</p><h3 id="vue-ui安装"><a href="#vue-ui安装" class="headerlink" title="vue-ui安装"></a>vue-ui安装</h3><h2 id="自定义配置："><a href="#自定义配置：" class="headerlink" title="自定义配置："></a>自定义配置：</h2><p>此时很多朋友会问了，没有配置文件，那我需要自定义一个配置咋办呢？<br>莫慌，此时我们只需要在项目根目录新建一个 vue.config.js 文件就能使用自定义配置了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  baseUrl: process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">    ? &apos;/production-sub-path/&apos;</span><br><span class="line">    : &apos;/&apos;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: 8000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组件使用规范"><a href="#组件使用规范" class="headerlink" title="组件使用规范"></a>组件使用规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a、动态传值，使用 :prop = &apos;&apos;</span><br><span class="line">b、在非 template/render 模式下（例如使用 CDN 引用时），</span><br><span class="line">   组件名要分隔（驼峰命名改为烤肉串），例如 DatePicker 必须要写成 date-picker</span><br><span class="line">c、以下组件，在非 template/render 模式下，需要加前缀 i-：</span><br><span class="line">    ·Button: i-button</span><br><span class="line">    ·Col: i-col</span><br><span class="line">    ·Table: i-table</span><br><span class="line">    ·Input: i-input</span><br><span class="line">    ·Form: i-form</span><br><span class="line">    ·Menu: i-menu</span><br><span class="line">    ·Select: i-select</span><br><span class="line">    ·Option: i-option</span><br><span class="line">    ·Progress: i-progress</span><br><span class="line">   以下组件，在所有模式下，必须加前缀 i-，除非使用 iview-loader：</span><br><span class="line">     ·Switch: i-switch</span><br><span class="line">     ·Circle: i-circle</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用箭头函数this为空,箭头函数会改变this指向</p><p>Try changing the iView import statement to the following:</p><p>import iView from ‘iview/dist/iview.min’;<br>Frequently you’ll find that distribution packages contain the production version of the library located within a dist directory. Seeing as the stylesheet is located there, I’d assume the js is there as well.</p><p>// likely that the iview js in this directory<br>import ‘iview/dist/styles/iview.css’;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境基础&quot;&gt;&lt;a href=&quot;#环境基础&quot; class=&quot;headerlink&quot; title=&quot;环境基础&quot;&gt;&lt;/a&gt;环境基础&lt;/h2&gt;&lt;p&gt;vue-cli 3.x搭建环境&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>VUE(三)：安装vue-cli 3.x</title>
    <link href="https://victoryofymk.github.io/2018/10/25/vue%E5%AE%89%E8%A3%85vue-cli3.x/"/>
    <id>https://victoryofymk.github.io/2018/10/25/vue安装vue-cli3.x/</id>
    <published>2018-10-25T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --g @vue/cli</span><br></pre></td></tr></table></figure><h3 id="创建模板项目"><a href="#创建模板项目" class="headerlink" title="创建模板项目"></a>创建模板项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create 【项目名称】</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>通过cli 3.x 新建的项目的结构较之前简单，只有 public 和 src 两个文件夹</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="配置启动脚本-packge-json-gt-script"><a href="#配置启动脚本-packge-json-gt-script" class="headerlink" title="配置启动脚本(packge.json &gt; script)"></a>配置启动脚本(packge.json &gt; script)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;vue-cli-service serve --open&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;,</span><br><span class="line">    &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;,</span><br><span class="line">    &quot;test:e2e&quot;: &quot;vue-cli-service test:e2e&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"># 可参考文档 https://cli.vuejs.org/guide/cli-service.html</span><br></pre></td></tr></table></figure><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 选择执行dev环境脚本</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="调整webpack配置"><a href="#调整webpack配置" class="headerlink" title="调整webpack配置"></a>调整webpack配置</h3><p>在根目录下新建文件vue.config.js<br>文档参考 <a href="https://cli.vuejs.org/guide/webpack.html" target="_blank" rel="noopener">https://cli.vuejs.org/guide/webpack.html</a><br>在根目录下新建.env .env.development .env.production文件，并修改启动脚本，实现加载不同环境下配置 </p><p>vue.config.js参考配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const resolve = dir =&gt; &#123;</span><br><span class="line">    return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">const BASE_URL = process.env.BASE_URL</span><br><span class="line">// 参见:https://cli.vuejs.org/guide/webpack.html</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    baseUrl: BASE_URL, // 根域上下文目录</span><br><span class="line">    outputDir: &apos;dist&apos;, // 构建输出目录</span><br><span class="line">    // assetsDir: &apos;assets&apos;, // 静态资源目录 (js, css, img, fonts)</span><br><span class="line">    // pages: vueConf.pages,</span><br><span class="line">    lintOnSave: true, // 是否开启eslint保存检测，有效值：ture | false | &apos;error&apos;</span><br><span class="line">    runtimeCompiler: true, // 运行时版本是否需要编译</span><br><span class="line">    transpileDependencies: [], // 默认babel-loader忽略mode_modules，这里可增加例外的依赖包名</span><br><span class="line">    productionSourceMap: false, // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度</span><br><span class="line">    //加载器</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(&apos;@&apos;, resolve(&apos;src&apos;))</span><br><span class="line">            .set(&apos;_c&apos;, resolve(&apos;src/components&apos;))</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: true,</span><br><span class="line">        host: &apos;localhost&apos;,</span><br><span class="line">        port: 8080,</span><br><span class="line">        https: false,</span><br><span class="line">        hotOnly: false,</span><br><span class="line">        //代理</span><br><span class="line">        proxy: null,</span><br><span class="line">        before: app =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="添加其他组件"><a href="#添加其他组件" class="headerlink" title="添加其他组件"></a>添加其他组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 如安装包 @vue/cli-plugin-eslint</span><br><span class="line">vue add @vue/eslint</span><br><span class="line"># 如安装包 @foo/vue-cli-plugin-bar</span><br><span class="line">vue add @foo/bar</span><br><span class="line">#安装vuex 和 vue-router是例外</span><br><span class="line">vue add router</span><br><span class="line">vue add vuex</span><br></pre></td></tr></table></figure><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">可发布生产(dependencies):</span><br><span class="line">    vue // 包含vue-loader（必要组件）</span><br><span class="line">    vue-router // vue 路由 （重要组件）</span><br><span class="line">    vuex // 全局响应式状态仓库 （重要组件）</span><br><span class="line">    axios // vue http请求 （重要组件）</span><br><span class="line">    iview // iView UI框架</span><br><span class="line">    iview-area // 基于Iview的城市级联组件</span><br><span class="line">    clipboard // 轻量级的实现复制文本到剪贴板功能的JavaScript插件</span><br><span class="line">    codemirror // 文本编辑器插件</span><br><span class="line">    countup // 数字数据的动画</span><br><span class="line">    cropperjs //图像裁剪器。</span><br><span class="line">    echarts // 图表</span><br><span class="line">    html2canvas  //浏览器截图插件 </span><br><span class="line">    js-cookie // 轻量级的JavaScript API，用于处理cookie</span><br><span class="line">    simplemde // Markdown编辑器</span><br><span class="line">    sortablejs // 重新排序的拖放列表的JavaScript库。</span><br><span class="line">    vue-i18n // vue国际化</span><br><span class="line">    wangeditor // 轻量级web富文本编辑器</span><br><span class="line">仅在开发环境(devDependencies):</span><br><span class="line">    vue-template-compiler // vue-template组件（必要组件）,版本必须与vue保持一致</span><br><span class="line">    @vue/cli-plugin-babel // ES标准转换组件(必要组建)</span><br><span class="line">    @vue/cli-service // cli-service服务，如运行 构建 测试(必要组件)</span><br><span class="line">    less less-loader // less-loader(必要组件),将less编译为css,将css文件当做模块来处理 style标签里加上lang=”less”里面就可以写less的代码了style标签里加上scoped表示只在此作用域有效</span><br><span class="line">    @vue/cli-plugin-eslint @vue/eslint-config-standard // 语法检查</span><br><span class="line">    eslint-plugin-cypress lint-staged // 用于测试环境的语法检查插件</span><br><span class="line">    @vue/cli-plugin-unit-mocha // 使用mocha-webpack + chai运行单元测试。</span><br><span class="line">    @vue/test-utils // Vue.js的官方测试库。它提供了单元测试Vue组件的方法。</span><br><span class="line">    chai // Chai是节点和浏览器的BDD / TDD断言库，可以与任何javascript测试框架配对。</span><br><span class="line">    mockjs //模拟数据生成器，帮助前端开发和原型与后端进程分离，并在编写自动化测试时特别减少一些单调性。</span><br></pre></td></tr></table></figure><p>执行脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不是&apos;@vue/cli-plugin-&apos;开头的组件用以下安装方式</span><br><span class="line">npm install -save -dev @vue/eslint-config-standard vuex iview echarts mockjs</span><br><span class="line"># 是&apos;@vue/cli-plugin-【name】&apos;开头的组件可以以下方式安装</span><br><span class="line">vue add name</span><br></pre></td></tr></table></figure></p><h2 id="安装vue-ui"><a href="#安装vue-ui" class="headerlink" title="安装vue-ui"></a>安装vue-ui</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Install:</span><br><span class="line"></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"># OR</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><p>Create a project:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create my-project</span><br><span class="line"># OR</span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure></p><p>安装过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.0.5</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors</span><br><span class="line">? Use history mode for router? (Requires proper server setup for index fallback in production) Yes</span><br><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less</span><br><span class="line">? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files</span><br><span class="line">? Save this as a preset for future projects? (y/N) y</span><br></pre></td></tr></table></figure></p><p>启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn serve </span><br><span class="line">// OR</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure></p><p>启动UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure></p><h2 id="卸载重装"><a href="#卸载重装" class="headerlink" title="卸载重装"></a>卸载重装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm uninstall -g vue</span><br><span class="line">$ sudo npm uninstall -g vue-cli</span><br><span class="line">$ sudo npm uninstall -g @vue/cli</span><br><span class="line">$ sudo npm cache clean --force</span><br><span class="line">$ sudo npm install -g vue</span><br><span class="line">$ sudo npm install -g @vue/cli</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;h3 id=&quot;安装vue-cli&quot;&gt;&lt;a href=&quot;#安装vue-cli&quot; class=&quot;headerlink&quot; title=&quot;安装vue-c
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>VUE(二)：安装vue-cli</title>
    <link href="https://victoryofymk.github.io/2018/10/24/vue%E5%AE%89%E8%A3%85vue-cli/"/>
    <id>https://victoryofymk.github.io/2018/10/24/vue安装vue-cli/</id>
    <published>2018-10-24T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h2><p>假设你的机子上已经有了最新的node和npm了，那我们就只需要执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br></pre></td></tr></table></figure></p><p>构建完了之后，随便进入一个我们事先准备好的目录，比如demo目录，然后在目录中做初始化操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vue init 是vue初始化项目</span><br><span class="line"># webpack 是打包工具，其中也可以使用Browserify，感兴趣可以自行研究</span><br><span class="line"># project 是自定义的项目名称</span><br><span class="line">$ vue init webpack myProject</span><br></pre></td></tr></table></figure></p><p>webpack参数是指myProject这个项目将会在开发和完成阶段帮你自动打包代码，比如将js文件统一合成一个文件，将CSS文件统一合并压缩等。</p><p>安装中的提示信息,可以修改和选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">? Project name vueproject   ---------------------项目名称</span><br><span class="line">? Project description A Vue.js project---------------------项目描述</span><br><span class="line">? Author wondershoter &lt;starlord.yan@gmail.com&gt;---------------------作者</span><br><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes---------------------是否安装Vue路由，推荐安装，是页面跳转用的</span><br><span class="line">? Use ESLint to lint your code? Yes---------------------是否启用eslint检测规则</span><br><span class="line">? Set up unit tests no---------------------是否安装单元测试,选择否，不然安装依赖会卡住</span><br><span class="line">? Setup e2e tests with Nightwatch? Yes---------------------是否安装e2e测试</span><br><span class="line">? Should we run `npm install` for you after the project has been created? (recommended) npm</span><br></pre></td></tr></table></figure></p><p>按照提示信息启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd myProject</span><br><span class="line"># 安装依赖，如果要具体安装其他模块可以单独使用，执行之后，目录里多了一个node_modules文件夹，这里放的就是所有依赖的模块</span><br><span class="line">npm install #如果安装过程已经执行，略过；</span><br><span class="line"># 运行项目</span><br><span class="line">npm run dev </span><br><span class="line"># 打包工作，用于正式环境</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure></p><p>npm run dev 是开始执行我们的项目了，一旦执行这个命令之后，等一小会，浏览器应该会自动帮你打开一个tab为<a href="http://localhost:8080/#/的链接，这个链接就是我们本地开发的项目主页" target="_blank" rel="noopener">http://localhost:8080/#/的链接，这个链接就是我们本地开发的项目主页</a></p><p>修改端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 文件目录分析</span><br><span class="line">package.json保存一些依赖信息，config保存一些项目初始化配置，build里面保存一些webpack的初始化配置，index.html是我们的首页，除了这些，最关键的代码都在src目录中，index在很多服务器语言中都是预设为首页，像index.htm，index.php等</span><br></pre></td></tr></table></figure></p><p>build    ——————-项目构建相关代码（webpack配置）<br>    build.js  ————-生产环境构建代码<br>    check-versions.js  ———-检查node、npm等版本<br>    utils.js  ————————构建工具相关<br>    vue-loader.conf.js  ———css加载器的配置<br>    webpack.base.conf.js  —webpack的基础配置信息<br>    webpack.dev.conf.js  —–webpack开发环境配置信息，构建开发本地服务器<br>    webpack.prod.conf.js  —wenpack生产环境配置信息<br>config    ——————-配置目录，包括端口号，打包输出等的vue基本配置文件<br>    dev.env.js  ———–开发环境变量<br>    prod.env.js ———–生产环境变量<br>    index.js  ————-项目的配置变量，端口号等<br>node_modules    ———–加载的项目依赖模块<br>static    ——————-静态资源目录<br>index.html    —————首页的入口文件，可以添加meta等参数<br>README.md    —————项目的说明文档，makedown格式<br>src    ———————–源码目录，主要的开发<br>    assets  —————静态资源，css,image等可以存放<br>    components  ———–公共组件<br>    router  —————路由文件夹，配置页面跳转<br>    views  —————-页面编写的地方，（可以自行定义命名）<br>main.js  ——————入口文件，全局的配置和加载<br>.babelrc  —————–ES6语法编译配置，用来将es6代码转换成浏览器可识别的es5代码<br>.gitignore  —————git上传需要忽略的文件的格式<br>package.json  ————-项目的基本信息，包括开发所需要的模块、项目名称、版本号等<br>.postcssrc.js  ————转换css的工具<br>.editorconfig  ————定义代码格式<br><code>`</code></p><p>入口js文件在src目录中的main.js</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Babel，转译成浏览器可识别的语言，可以让你的项目支持更新的语法，如es6\es7等<br>PWA，模拟原生app，渐进式网络应用程序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装vue-cli&quot;&gt;&lt;a href=&quot;#安装vue-cli&quot; class=&quot;headerlink&quot; title=&quot;安装vue-cli&quot;&gt;&lt;/a&gt;安装vue-cli&lt;/h2&gt;&lt;p&gt;假设你的机子上已经有了最新的node和npm了，那我们就只需要执行以下命令：&lt;br&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(九)：Hexo+Github+TravisCI部署到Github与自己的服务器</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo+Github+TravisCI%E9%83%A8%E7%BD%B2%E5%88%B0Github%E4%B8%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo+Github+TravisCI部署到Github与自己的服务器/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>使用hexo在github上搭blog最大的问题就是，每次提交都需要先hexo -g，然后再deploy生成的文件们，这样哪怕是改一个小的地方都需要重新编译全部blog，因此使用Travis来自动持续集成提交到github以后的操作，具体逻辑：</p><ul><li>写完blog后，直接push到github的source分支，其它的就可以不用管了</li><li>由于我的.travis.yml配置文件里设置监听的就是source分支，所以会触发webhook</li><li>Travis则会将该项目clone过去，然后按照.travis.yml的设置执行接下来的命令</li><li>执行完成后，再将编译好的文件们发送到自己的服务器，顺便push回master分支上来</li><li>这样就可以在blog.godi13.com和Godi13.github.io上都访问blog了</li></ul><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>为了使travis能够将编译好的文件们push回github，我们需要生成token，步骤如下：<br>1) 点击github右上方头像，然后点setting，或者<a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a><br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023150449.png" alt=""><br>2) 点击Developer settings<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023154052.png" alt=""><br>3) 进入Personal access tokens，点击Generate new token,为token起一个名字，勾选repo，然后点击生成,生成token以后，一定要复制好，因为只显示一次，如果丢失只能再次生成<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023150618.png" alt=""></p><h3 id="Travis"><a href="#Travis" class="headerlink" title="Travis"></a>Travis</h3><p>1) 使用github帐号登录Travis，右上方按钮点击同步项目，下方打开需要集成的项目，最后点击齿轮进入项目配置页面<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023154227.png" alt=""><br>2) 勾选相应配置，然后往下移动页面到环境变量<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023150236.png" alt=""><br>3) 在这里我将变量名称名为REPO_TOKEN，放上token，点击Add按钮<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023145955.png" alt=""></p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>回到终端，进入blog所在的文件夹下，新建.travis.yml文件，并添加以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 使用语言</span><br><span class="line">language: node_js</span><br><span class="line"># node版本</span><br><span class="line">node_js: stable</span><br><span class="line"># 设置只监听哪个分支</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - source</span><br><span class="line"># 缓存，可以节省集成的时间，这里我用了yarn，如果不用可以删除</span><br><span class="line">cache:</span><br><span class="line">  apt: true</span><br><span class="line">  yarn: true</span><br><span class="line">  directories:</span><br><span class="line">    - node_modules</span><br><span class="line"># tarvis生命周期执行顺序详见官网文档</span><br><span class="line">before_install:</span><br><span class="line">- git config --global user.name &quot;Godi13&quot;</span><br><span class="line">- git config --global user.email &quot;mqzq9388@gmail.com&quot;</span><br><span class="line"># 由于使用了yarn，所以需要下载，如不用yarn这两行可以删除</span><br><span class="line">- curl -o- -L https://yarnpkg.com/install.sh | bash</span><br><span class="line">- export PATH=$HOME/.yarn/bin:$PATH</span><br><span class="line">- npm install -g hexo-cli</span><br><span class="line">install:</span><br><span class="line"># 不用yarn的话这里改成 npm i 即可</span><br><span class="line">- yarn</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo generate</span><br><span class="line">after_success:</span><br><span class="line">- cd ./public</span><br><span class="line">- git init</span><br><span class="line">- git add --all .</span><br><span class="line">- git commit -m &quot;Travis CI Auto Builder&quot;</span><br><span class="line"># 这里的 REPO_TOKEN 即之前在 travis 项目的环境变量里添加的</span><br><span class="line">- git push --quiet --force https://$REPO_TOKEN@github.com/Godi13/Godi13.github.io.git</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p><p>然后，准备push该项目到github，看下是否成功，如果是新项目可参照下面的git指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"># 添加自己的项目</span><br><span class="line">git remote add origin git@github.com:Godi13/Godi13.github.io.git</span><br><span class="line"># 新建并切换分支</span><br><span class="line">git checkout --orphan source</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;Travis CI&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>关于 –orphan 请参考<a href="https://ihower.tw/blog/archives/5691" target="_blank" rel="noopener">如何建立一個沒有 Parent 的獨立 Git branch</a></p><p>如最终成功则会看到<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181023145751.png" alt=""></p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>未完…</p><p>参考资料<br><a href="https://segmentfault.com/a/1190000009054888" target="_blank" rel="noopener">使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器</a><br><a href="https://github.com/tommy351/tommy351.github.io/blob/source/.travis.yml" target="_blank" rel="noopener">Hexo作者的.travis.yml配置</a><br><a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="noopener">用 Travis CI 自動部署網站到 GitHub</a><br><a href="https://zhuanlan.zhihu.com/p/25066056" target="_blank" rel="noopener">一点都不高大上，手把手教你使用Travis CI实现持续部署</a><br><a href="http://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/" target="_blank" rel="noopener">使用 Travis CI 自动更新 GitHub Pages</a><br><a href="http://magicse7en.github.io/2016/03/27/travis-ci-auto-deploy-hexo-github/" target="_blank" rel="noopener">使用Travis CI自动构建hexo博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自动部署&quot;&gt;&lt;a href=&quot;#自动部署&quot; class=&quot;headerlink&quot; title=&quot;自动部署&quot;&gt;&lt;/a&gt;自动部署&lt;/h2&gt;&lt;p&gt;使用hexo在github上搭blog最大的问题就是，每次提交都需要先hexo -g，然后再deploy生成的文件们，这样哪
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(六)：绑定个人域名</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo绑定个人域名/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到<a href="https://link.jianshu.com/?t=https%253A%252F%252Fsg.godaddy.com%252Fzh%252F" target="_blank" rel="noopener">GoDaddy官网</a>，，也可以到<a href="https://link.jianshu.com/?t=http%253A%252F%252Fwanwang.aliyun.com%252F" target="_blank" rel="noopener">阿里万网</a>购买。</p><h3 id="1-Github端"><a href="#1-Github端" class="headerlink" title="1.Github端"></a>1.Github端</h3><p>在/blog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：victoryofymk.com写入。</p><p>终端cd到blog目录下执行如下命令重新部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>注意：网上许多都是说在Github上直接新建CNAME文件，如果这样的话，在你下一次执行hexo d部署命令后CNAME文件就消失了，因为本地没有此文件。</p><h3 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2.域名解析"></a>2.域名解析</h3><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –> 添加解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">记录类型：CNAME</span><br><span class="line">主机记录：将域名解析为[example.com](https://link.jianshu.com/?t=http%253A%252F%252Fexample.com)（不带www），填写@或者不填写</span><br><span class="line">记录值：victoryofymk.github.io. (victoryofymk改为你自己的用户名)，点击保存即可</span><br><span class="line">域名解析</span><br></pre></td></tr></table></figure></p><p>此时，点击访问<a href="https://link.jianshu.com/?t=http%253A%252F%252Fgonghonglou.com" target="_blank" rel="noopener">http://victoryofymk.com</a>和访问<a href="https://link.jianshu.com/?t=http%253A%252F%252Fgonghonglou.github.io" target="_blank" rel="noopener">http://victoryofymk.github.io</a>效果一致，大功告成！</p><p>参考的文章：<br>  1.<a href="http://gonghonglou.com/2016/02/03/firstblog/" target="_blank" rel="noopener">http://gonghonglou.com/2016/02/03/firstblog/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;绑定个人域名&quot;&gt;&lt;a href=&quot;#绑定个人域名&quot; class=&quot;headerlink&quot; title=&quot;绑定个人域名&quot;&gt;&lt;/a&gt;绑定个人域名&lt;/h2&gt;&lt;p&gt;现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(七)：第三方服务</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo集成第三方服务/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>为hexo增加评论功能</p><h3 id="添加disqus评论"><a href="#添加disqus评论" class="headerlink" title="添加disqus评论"></a>添加disqus评论</h3><p>使用该评论功能需要“科学上网”。</p><p>1.注册disqus账号<a href="https://disqus.com" target="_blank" rel="noopener">https://disqus.com</a></p><p>2.在disqus设置页面中点 Add Disqus to your site 添加你的网站地址(即为<a href="https://yourname.github.io)" target="_blank" rel="noopener">https://yourname.github.io)</a>, 和设置Choose your unique Disqus URL, 你所填写的unique Disqus URL即为hexo配置文件中需要修改的short_name字段。</p><p>3.评论预审核可以不填写<br>4.第一次需要验证邮箱<br>5.打开hexo/themes/next/_config.yml主题配置文件，修改下面字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Disqus</span><br><span class="line">disqus:</span><br><span class="line">  enable: true</span><br><span class="line">  shortname:     #shortname即为你上面填写的唯一disqus路径，填上就好</span><br><span class="line">  count: true</span><br></pre></td></tr></table></figure></p><h3 id="添加Hypercomments"><a href="#添加Hypercomments" class="headerlink" title="添加Hypercomments"></a>添加Hypercomments</h3><p>来自俄罗斯,提供付费和免费的服务</p><h3 id="添加Valine"><a href="#添加Valine" class="headerlink" title="添加Valine"></a>添加Valine</h3><p>基于LeanCloud，也支持阅读量等，免费版有一定限制首先API请求每天30000，存储10G</p><p>修改next主题配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: false # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid:  # your leancloud application appid</span><br><span class="line">  appkey:  # your leancloud application appkey</span><br><span class="line">  notify: false # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: Just go go # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br></pre></td></tr></table></figure><p>appid,appkey 填写leancloud的应用注册后提供的即可，参考另一篇博客或者站内搜索</p><h3 id="添加Gitment"><a href="#添加Gitment" class="headerlink" title="添加Gitment"></a>添加Gitment</h3><p>基于github的issue实现的,不再维护</p><h3 id="添加Gitalk"><a href="#添加Gitalk" class="headerlink" title="添加Gitalk"></a>添加Gitalk</h3><p>基于github的issue实现的,有人维护</p><p>登陆GitHub，然后点击头像，然后Settings，Developer settings,然后，点击OAuth Apps，New OAuth App创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">Application name： # 应用名称，随意</span><br><span class="line">Homepage URL： # 网站URL，如https://asdfv1929.github.io</span><br><span class="line">Application description # 描述，随意</span><br><span class="line">Authorization callback URL：# 网站URL，https://asdfv1929.github.io</span><br></pre></td></tr></table></figure></p><p>创建完成后client id和client secret在配置文件中需要使用</p><p>修改next主题配置，新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Gitalk评论</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  owner: #这个项目名的拥有者（GitHub账号或组织）</span><br><span class="line">  repo: #你要存放的项目名</span><br><span class="line">  admin: #这个项目名的拥有者（GitHub账号或组织）</span><br><span class="line">  labels: gitalk #GitHub issues的标签，下面会详细说</span><br><span class="line">  clientID: #client id</span><br><span class="line">  clientSecret: #client secret</span><br><span class="line">  gitalk_css: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css </span><br><span class="line">  gitalk_js: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js #</span><br><span class="line">  md5: //cdn.bootcss.com/blueimp-md5/1.1.0/js/md5.min.js</span><br></pre></td></tr></table></figure><p>gitalk.swig如果已经配置css和js可以省略，md5加密ID可以解决gitbub对Issue label长度最多50的限制。</p><p>另外可以参考next对于gitment等其他评论插件的集成。</p><h4 id="配置主题方法一"><a href="#配置主题方法一" class="headerlink" title="配置主题方法一"></a>配置主题方法一</h4><p>找到NexT的主题目录，然后进入这个路径/next/layout/_custom/下，应该有head.swig，header.swig，sidebar.swig这三个文件。<br>这三个文件应该就是自定义布局的位置。然后，在sidebar.swig里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments and config.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; config.gitalk.gitalk_css &#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;&#123;&#123; config.gitalk.gitalk_js &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;&#123;&#123; config.gitalk.md5 &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      var gitalk = new Gitalk(&#123;</span><br><span class="line">        clientID: &apos;&#123;&#123; config.gitalk.clientID &#125;&#125;&apos;,</span><br><span class="line">        clientSecret: &apos;&#123;&#123; config.gitalk.clientSecret &#125;&#125;&apos;,</span><br><span class="line">        repo: &apos;&#123;&#123; config.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">        owner: &apos;&#123;&#123; config.gitalk.owner &#125;&#125;&apos;,</span><br><span class="line">        admin: &apos;&#123;&#123; config.gitalk.admin &#125;&#125;&apos;,</span><br><span class="line">        id: md5(location.pathname),</span><br><span class="line">        distractionFreeMode: &apos;true&apos;</span><br><span class="line">      &#125;);</span><br><span class="line">      var div = document.createElement(&apos;div&apos;);</span><br><span class="line">      div.setAttribute(&quot;id&quot;, &quot;gitalk_comments&quot;);</span><br><span class="line">      div.setAttribute(&quot;class&quot;, &quot;post-nav&quot;);</span><br><span class="line">      var bro = document.getElementById(&apos;posts&apos;).getElementsByTagName(&apos;article&apos;);</span><br><span class="line">      bro = bro[0].getElementsByClassName(&apos;post-block&apos;);</span><br><span class="line">      bro = bro[0].getElementsByTagName(&apos;footer&apos;);</span><br><span class="line">      bro = bro[0];</span><br><span class="line">      bro.appendChild(div);</span><br><span class="line">      gitalk.render(&apos;gitalk_comments&apos;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://yunhao.space/2018/07/04/hexo-next-gitalk-comments-tutor/" target="_blank" rel="noopener">https://yunhao.space/2018/07/04/hexo-next-gitalk-comments-tutor/</a></p><h4 id="配置主题方法二"><a href="#配置主题方法二" class="headerlink" title="配置主题方法二"></a>配置主题方法二</h4><p>以NexT主题做示范，毕竟其他的也是大同小异。<br>在主题的\layout_third-party\comments目录中，新建一个gitalk.swig文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;&#123;&#123; theme.gitalk.md5 &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.admin &#125;&#125;&apos;],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>还是，在主题的\layout_third-party\comments目录中，找到一个index.swig的文件，打开，添加这一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></p><p>接着，在主题的\layout_partials目录中，找到comments.swig文件，打开，找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">  &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">  &lt;/div&gt;  </span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在空了一行的地方加上以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure><p>修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure><h2 id="添加百度分享功能"><a href="#添加百度分享功能" class="headerlink" title="添加百度分享功能"></a>添加百度分享功能</h2><p>百度分享功能的添加可以参考下面这篇博客。<a href="http://blog.csdn.net/cl534854121/article/details/76121105" target="_blank" rel="noopener">Hexo+Github搭建个人博客(三)——百度分享集成</a></p><h2 id="百度统计访客访问量功能"><a href="#百度统计访客访问量功能" class="headerlink" title="百度统计访客访问量功能"></a>百度统计访客访问量功能</h2><p>其他酷炫小功能参考<a href="http://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;评论系统&quot;&gt;&lt;a href=&quot;#评论系统&quot; class=&quot;headerlink&quot; title=&quot;评论系统&quot;&gt;&lt;/a&gt;评论系统&lt;/h2&gt;&lt;p&gt;为hexo增加评论功能&lt;/p&gt;
&lt;h3 id=&quot;添加disqus评论&quot;&gt;&lt;a href=&quot;#添加disqus评论&quot; clas
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>JDK版本变化</title>
    <link href="https://victoryofymk.github.io/2018/10/23/JDK%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96/"/>
    <id>https://victoryofymk.github.io/2018/10/23/JDK版本变化/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录一下JDK版本的历史更新和重要特性。</p><p>目前JDK更新较快，每半年发布一个版本，但是对于生产环境采用仍然建议使用LTS(长期支持版本)版本</p><p>按照 Oracle 公布的支持路线图，Java 11 将会获得 Oracle 提供的长期支持服务，直至2026年9月。<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/JDK%20%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96-1.png" alt=""></p><p>根据官网从Java 11开始提供用开源许可证和商业许可证的组合</p><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><ul><li>2018-11-09 补充JDK8的介绍和使用</li></ul><h2 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h2><ul><li>JCP 是 Java Community Process（Java社区进程）的简称，社会各界Java组成的社区，规划和领导Java的发展。</li><li>JEP 是 JDK Enhancement Proposals （Java 增强提案）的简称，JDK的版本变化将从这些提案中选取。</li><li>JSR 是 Java Specification Requests（Java规范请求）的简称，是 JCP 成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过会成为 JEP，最终会体现在未来的Java中。</li><li>TCK 是 Technology Compatibility Kit（技术兼容性测试）的简称， 如果一个平台型程序想要宣称自己兼容Java，就必须通过TCK测试</li></ul><h2 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h2><ul><li>集合框架增强。</li></ul><ol><li>为了更好的支持双向访问集合。添加了许多新的类和接口。</li><li>新的数组拷贝方法。Arrays.copyOf和Arrays.copyOfRange</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//以下为添加的新接口和类</span><br><span class="line">Deque,BlockingDeque,NavigableSet,NavigableMap,ConcurrentNavigableMap，ArrayDeque， ConcurrentSkipListSet ,ConcurrentSkipListMap,ConcurrentSkipListMap ,AbstractMap.SimpleEntry ,AbstractMap.SimpleImmutableEntry</span><br></pre></td></tr></table></figure><ul><li>Scripting. 可以让其他语言在java平台上运行。 java6包含了一个基于Mozilla Rhino实现的javascript脚本引擎。</li><li>支持JDBC4.0规范。</li></ul><h2 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h2><ul><li>二进制前缀0b或者0B。整型（byte, short, int, long）可以直接用二进制表示。</li><li>字面常量数字的下划线。用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾。</li><li>switch 支持String类型。</li><li>泛型实例化类型自动推断。</li><li>try-with-resources语句。</li><li>单个catch中捕获多个异常类型（用| 分割）并通过改进的类型检查重新抛出异常。</li></ul><h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><ul><li>Lambda 表达式(Lambda Expressions) − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</li><li>方法引用（Method references） − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li>默认方法 （Default methods）− 默认方法就是一个在接口里面有了一个实现的方法。</li><li>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li>Date Time API − 加强对日期与时间的处理。</li><li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li><li><p>java.util 包下的改进，提供了几个实用的工具类。<br>并行数组排序。<br>标准的Base64编解码。<br>支持无符号运算。</p></li><li><p>java.util.concurrent 包下增加了新的类和方法。<br>java.util.concurrent.ConcurrentHashMap 类添加了新的方法以支持新的StreamApi和lambada表达式。<br>java.util.concurrent.atomic 包下新增了类以支持可伸缩可更新的变量。<br>java.util.concurrent.ForkJoinPool类新增了方法以支持 common pool。<br>新增了java.util.concurrent.locks.StampedLock类，为控制读/写访问提供了一个基于性能的锁，且有三种模式可供选择。</p></li><li><p>HotSpot<br>删除了 永久代（PermGen）.<br>方法调用的字节码指令支持默认方法。</p></li><li><p>重复注解（Repeating Annotations）。重复注解提供了在同一声明或类型中多次应用相同注解类型的能力。</p></li><li>类型注解（Type Annotation）。在任何地方都能使用注解，而不是在声明的地方。</li><li>类型推断增强</li><li>方法参数反射（Method Parameter Reflection）。</li><li>HashMap改进，在键值哈希冲突时能有更好表现。</li></ul><p>部分特性说明：</p><h3 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h3><p>Lambda 表达式，也可称为闭包，允许把函数作为一个方法的参数</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>lambda 表达式的语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure></p><p>以下是lambda表达式的重要特征:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</span><br></pre></td></tr></table></figure><p>Lambda 表达式实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line"># 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line"># 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line"># 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line"># 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><h3 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2.方法引用"></a>2.方法引用</h3><p>方法引用通过方法的名字来指向一个方法,可以使语言的构造更紧凑简洁，减少冗余代码。方法引用使用一对冒号 ::</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car car = Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure></p><p>静态方法引用：它的语法是Class::static_method，实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure></p><p>特定类的任意对象的方法引用：它的语法是Class::method实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure></p><p>特定对象的方法引用：它的语法是instance::method实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car police = Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure></p><p>方法引用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List names = new ArrayList();</span><br><span class="line">        </span><br><span class="line">      names.add(&quot;Google&quot;);</span><br><span class="line">      names.add(&quot;Runoob&quot;);</span><br><span class="line">      names.add(&quot;Taobao&quot;);</span><br><span class="line">      names.add(&quot;Baidu&quot;);</span><br><span class="line">      names.add(&quot;Sina&quot;);</span><br><span class="line">        </span><br><span class="line">      names.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p><p>函数式接口可以被隐式转换为 lambda 表达式。</p><p>如定义了一个函数式接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface GreetingService </span><br><span class="line">&#123;</span><br><span class="line">    void sayMessage(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br></pre></td></tr></table></figure></p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8 新增了接口的默认方法。<br>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。<br>我们只需在方法名前面加个default关键字即可实现默认方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么要有这个特性？</span><br><span class="line"></span><br><span class="line">首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</span><br></pre></td></tr></table></figure><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>默认方法语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个默认方法<br>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解决方案可以使用 super 来调用指定接口的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态默认方法<br>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    // 静态方法</span><br><span class="line">   static void blowHorn()&#123;</span><br><span class="line">      System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>以上的流程转换为 Java 代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure><h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。<br>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。<br>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。<br>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。<br>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</p><h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><p>stream() − 为集合创建串行流。</p><p>parallelStream() − 为集合创建并行流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">// 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h4><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><p>我们可以很容易的在顺序运行和并行直接切换。</p><h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><h3 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h3><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>Optional 类的引入很好的解决空指针异常。</p><p>类声明<br>以下是一个 java.util.Optional<t> 类的声明：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br></pre></td></tr></table></figure><h3 id="Nashorn-JavaScript"><a href="#Nashorn-JavaScript" class="headerlink" title="Nashorn JavaScript"></a>Nashorn JavaScript</h3><p>Nashorn 一个 javascript 引擎。</p><p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p><p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p><h3 id="日期时间-API"><a href="#日期时间-API" class="headerlink" title="日期时间 API"></a>日期时间 API</h3><p>ava 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p><p>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</p><p>设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</p><p>时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</p><p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</p><p>Local(本地) − 简化了日期时间的处理，没有时区的问题。</p><p>Zoned(时区) − 通过制定的时区处理日期时间。</p><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>在Java 8中，Base64编码已经成为Java类库的标准。</p><p>Java 8 内置了 Base64 编码的编码器和解码器。</p><p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><p>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。<br>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。<br>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</p><h2 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h2><p>JDK 9 于2017年9月21日发布</p><p>新特性有：</p><ul><li>模块化 —— Jigsaw（Java Platform Module System）</li><li>交互式命令行 —— JShell</li><li>进程操作改进</li><li>竞争锁的性能优化</li><li>分段代码缓存</li><li>优化字符串占用空间</li><li>Javadoc<br>简化Doclet API。<br>支持生成HTML5格式。<br>加入了搜索框,使用这个搜索框可以查询程序元素、标记的单词和文档中的短语。<br>支持新的模块系统。</li><li>JVM<br>增强了Garbage-First(G1)并用它替代Parallel GC成为默认的垃圾收集器。<br>统一了JVM 日志，为所有组件引入了同一个日志系统。<br>删除了JDK 8中弃用的GC组合。（DefNew + CMS，ParNew + SerialOld，Incremental CMS）。</li><li>properties文件支持UTF-8编码,之前只支持ISO-8859-1。</li><li>支持Unicode 8.0，在JDK8中是Unicode 6.2。</li><li>支持私有接口方法(您可以使用diamond语法与匿名内部类结合使用)。</li><li>下划线不能用在变量名中。</li><li>diamond语法与匿名内部类结合使用。</li><li>新的版本号格式。$MAJOR.$MINOR.$SECURITY.$PATCH</li></ul><h2 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h2><p>北京时间 3 月 21 日，Oracle 官方宣布 Java 10 正式发布。新特性有：</p><ul><li>JEP 286: 局部变量的类型推导。该特性在社区讨论了很久并做了调查，可查看 JEP 286 调查结果。</li><li>JEP 296: 将 JDK 的多个代码仓库合并到一个储存库中。</li><li>JEP 304: 垃圾收集器接口。通过引入一个干净的垃圾收集器（GC）接口，改善不同垃圾收集器的源码隔离性。</li><li>JEP 307: 向 G1 引入并行 Full GC。</li><li>JEP 310: 应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中。</li><li>JEP 312: 线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程。</li><li>JEP 313: 移除 Native-Header Generation Tool (javah)</li><li>JEP 314: 额外的 Unicode 语言标签扩展。包括：cu (货币类型)、fw (每周第一天为星期几)、rg (区域覆盖)、tz (时区) 等。</li><li>JEP 316: 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆。</li><li>JEP 317: 基于 Java 的 JIT 编译器（试验版本）。</li><li>JEP 319: 根证书。开源 Java SE Root CA 程序中的根证书。</li><li>JEP 322: 基于时间的版本发布模式。“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug 。</li></ul><p>部分特性说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">1. var 类型推断。</span><br><span class="line"></span><br><span class="line">这个语言功能在其他一些语言 (C#、JavaScript) 和基于 JRE 的一些语言 (Scala 和 Kotlin) 中，早已被加入。</span><br><span class="line"></span><br><span class="line">在 Java 语言很早就在考虑，早在 2016 年正式提交了 JEP286 提议。后来举行了一次公开的开发者调查，获得最多建议的是采用类似 Scala 的方案，“同时使用 val 和 var”，约占一半；第二多的是“只使用 var”，约占四分之一。后来 Oracle 公司经过慎重考虑，采用了只使用 var 关键字的方案。</span><br><span class="line"></span><br><span class="line">有了这个功能，开发者在写这样的代码时：</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;()</span><br><span class="line">可以省去前面的类型声明，而只需要</span><br><span class="line"></span><br><span class="line">var list = new ArrayList&lt;String&gt;()</span><br><span class="line">编译器会自动推断出 list 变量的类型。对于链式表达式来说，也会很方便：</span><br><span class="line"></span><br><span class="line">var stream = blocks.stream(); </span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">int maxWeight = stream.filter(b -&gt; b.getColor() == BLUE)</span><br><span class="line"></span><br><span class="line">                      .mapToInt(Block::getWeight)</span><br><span class="line"></span><br><span class="line">                      .max();</span><br><span class="line">开发者无须声明并且 import 引入 Stream 类型，只用 stream 作为中间变量，用 var 关键字使得开发效率提升。</span><br><span class="line"></span><br><span class="line">不过 var 的使用有众多限制，包括不能用于推断方法参数类型，只能用于局部变量，如方法块中，而不能用于类变量的声明，等等。</span><br><span class="line"></span><br><span class="line">另外，我个人认为，对于开发者而言，变量类型明显的声明会提供更加全面的程序语言信息，对于理解并维护代码有很大的帮助。一旦 var 被广泛运用，开发者阅读三方代码而没有 IDE 的支持下，会对程序的流程执行理解造成一定的障碍。所以我建议尽量写清楚变量类型，程序的易读维护性有时更重要一些。</span><br><span class="line"></span><br><span class="line">2. 统一的 GC 接口</span><br><span class="line"></span><br><span class="line">在 JDK10 的代码中，路径为 openjdk/src/hotspot/share/gc/，各个 GC 实现共享依赖 shared 代码，GC 包括目前默认的 G1，也有经典的 Serial、Parallel、CMS 等 GC 实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 应用程序类数据（AppCDS）共享</span><br><span class="line"></span><br><span class="line">CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS(Application Class-Data Sharing) 支持。</span><br><span class="line"></span><br><span class="line">其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。</span><br><span class="line"></span><br><span class="line">我们可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。</span><br><span class="line"></span><br><span class="line">我在自己 PC 电脑上做以下应用启动实验。</span><br><span class="line"></span><br><span class="line">首先部署 wildfly 12 应用服务器，采用 JDK10 预览版作为 Java 环境。另外需要用到一个工具 cl4cds[1]，作用是把加载类的日志记录，转换为 AppCDS 可以识别的格式。</span><br><span class="line"></span><br><span class="line">A、安装好 wildfly 并部署一个应用，具有 Angularjs, rest, jpa 完整应用技术栈，预热后启动三次，并记录完成部署时间</span><br><span class="line"></span><br><span class="line">分别为 6716ms, 6702ms, 6613ms，平均时间为 6677ms。</span><br><span class="line"></span><br><span class="line">B、加入环境变量并启动，导出启动类日志</span><br><span class="line"></span><br><span class="line">export PREPEND_JAVA_OPTS=&quot;-Xlog:class+load=debug:file=/tmp/wildfly.classtrace&quot;</span><br><span class="line">C、使用 cl4cds 工具，生成 AppCDS 可以识别的 cls 格式</span><br><span class="line"></span><br><span class="line">/jdk-10/bin/java -cp src/classes/ io.simonis.cl4cds /tmp/wildfly.classtrace /tmp/wildfly.cls</span><br><span class="line">打开文件可以看到内容为：</span><br><span class="line"></span><br><span class="line">java/lang/Object id: 0x0000000100000eb0</span><br><span class="line"></span><br><span class="line">java/io/Serializable id: 0x0000000100001090</span><br><span class="line"></span><br><span class="line">java/lang/Comparable id: 0x0000000100001268</span><br><span class="line"></span><br><span class="line">java/lang/CharSequence id: 0x0000000100001440</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">org/hibernate/type/AssociationType id: 0x0000000100c61208 super: 0x0000000100000eb0 interfaces: 0x0000000100a00d10 source: /home/shihang/work/jboss/wildfly/dist/target/wildfly-12.0.0.Final/modules/system/layers/base/org/hibernate/main/hibernate-core-5.1.10.Final.jar</span><br><span class="line"></span><br><span class="line">org/hibernate/type/AbstractType id: 0x0000000100c613e0 super: 0x0000000100000eb0 interfaces: 0x0000000100a00d10 source: /home/shihang/work/jboss/wildfly/dist/target/wildfly-12.0.0.Final/modules/system/layers/base/org/hibernate/main/hibernate-core-5.1.10.Final.jar</span><br><span class="line"></span><br><span class="line">org/hibernate/type/AnyType id: 0x0000000100c61820 super: 0x0000000100c613e0 interfaces: 0x0000000100c61030 0x0000000100c61208 source: /home/shihang/work/jboss/wildfly/dist/target/wildfly-12.0.0.Final/modules/system/layers/base/org/hibernate/main/hibernate-core-5.1.10.Final.jar</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">这个文件用于标记类的加载信息。</span><br><span class="line"></span><br><span class="line">D、使用环境变量启动 wildfly，模拟启动过程并导出 jsa 文件，就是记录了启动时类的信息。</span><br><span class="line"></span><br><span class="line">export PREPEND_JAVA_OPTS=&quot;-Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=/tmp/wildfly.cls -XX:+UnlockDiagnosticVMOptions -XX:SharedArchiveFile=/tmp/wildfly.jsa&quot;</span><br><span class="line">查看产生的文件信息，jsa 文件有较大的体积。</span><br><span class="line"></span><br><span class="line">/opt/work/cl4cds$ ls -l /tmp/wildfly.*</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 shihang shihang   8413843 Mar 20 11:07 /tmp/wildfly.classtrace</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 shihang shihang   4132654 Mar 20 11:11 /tmp/wildfly.cls</span><br><span class="line"></span><br><span class="line">-r--r--r-- 1 shihang shihang 177659904 Mar 20 11:13 /tmp/wildfly.jsa</span><br><span class="line">E、使用 jsa 文件启动应用服务器</span><br><span class="line"></span><br><span class="line">export PREPEND_JAVA_OPTS=&quot;-Xshare:on -XX:+UseAppCDS -XX:+UnlockDiagnosticVMOptions -XX:SharedArchiveFile=/tmp/wildfly.jsa&quot;</span><br><span class="line">启动完毕后记录时长，三次分别是 5535ms, 5333ms, 5225ms，平均为 5364ms，相比之前的 6677ms 可以算出启动时间提升了 20% 左右。</span><br><span class="line"></span><br><span class="line">这个效率提升，对于云端应用部署很有价值。</span><br><span class="line"></span><br><span class="line">以上实验方法参考于技术博客 [2]。</span><br><span class="line"></span><br><span class="line">4. JEP314，使用附加的 Unicode 语言标记扩展。</span><br><span class="line"></span><br><span class="line">JDK10 对于 Unicode BCP 47 有了更多的支持，BCP 47 是 IETF 定义语言集的规范文档。使用扩展标记，可以更方便的获得所需要的语言地域环境。</span><br><span class="line"></span><br><span class="line">如 JDK10 加入的一个方法，</span><br><span class="line"></span><br><span class="line">java.time.format.DateTimeFormatter::localizedBy</span><br><span class="line">通过这个方法，可以采用某种数字样式，区域定义或者时区来获得时间信息所需的语言地域本地环境信息。</span><br><span class="line"></span><br><span class="line">附：从链接 [3] 可以看到 JDK10 所有的方法级别改动。</span><br><span class="line"></span><br><span class="line">5. 查看当前 JDK 管理根证书。</span><br><span class="line"></span><br><span class="line">自 JDK9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 OpenJDK9 中 cacerts 为空，这样就会给开发者带来很多不变。</span><br><span class="line"></span><br><span class="line">EP318 就是利用 Oracle 开源出 Oracle JavaSE 中的 cacerts 信息，在 OpenJDK 中提供一组默认的根证书颁发机构证书，目前有 80 条记录。</span><br><span class="line"></span><br><span class="line">/jdk-10/bin$ ./keytool -list -cacerts</span><br><span class="line"></span><br><span class="line">Enter keystore password:  </span><br><span class="line"></span><br><span class="line">Keystore type: JKS</span><br><span class="line"></span><br><span class="line">Keystore provider: SUN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your keystore contains 80 entries</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">verisignclass2g2ca [jdk], Dec 2, 2017, trustedCertEntry, </span><br><span class="line"></span><br><span class="line">Certificate fingerprint (SHA-256): 3A:43:E2:20:FE:7F:3E:A9:65:3D:1E:21:74:2E:AC:2B:75:C2:0F:D8:98:03:05:BC:50:2C:AF:8C:2D:9B:41:A1</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><p>JDK 11 总共包含 17 个新的 JEP ，分别为：</p><ul><li>181: Nest-Based Access Control（基于嵌套的访问控制）</li><li>309: Dynamic Class-File Constants（动态类文件常量）</li><li>315: Improve Aarch64 Intrinsics（改进 Aarch64 Intrinsics）</li><li>318: Epsilon: A No-Op Garbage Collector（Epsilon — 一个无操作的垃圾收集器）</li><li>320: Remove the Java EE and CORBA Modules（删除 Java EE 和 CORBA 模块）</li><li>321: HTTP Client (Standard)</li><li>323: Local-Variable Syntax for Lambda Parameters（用于 Lambda 参数的局部变量语法）</li><li>324: Key Agreement with Curve25519 and Curve448（Curve25519 和 Curve448 算法的密钥协议）</li><li>327: Unicode 10</li><li>328: Flight Recorder</li><li>329: ChaCha20 and Poly1305 Cryptographic Algorithms（ChaCha20 和 Poly1305 加密算法）</li><li>330: Launch Single-File Source-Code Programs（启动单一文件的源代码程序）</li><li>331: Low-Overhead Heap Profiling（低开销的 Heap Profiling）</li><li>332: Transport Layer Security (TLS) 1.3（支持 TLS 1.3）</li><li>333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) （可伸缩低延迟垃圾收集器）</li><li>335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）</li><li>336: Deprecate the Pack200 Tools and API （弃用 Pack200 工具和 API）</li></ul><p>支持Unicode 10.0,在jdk10中是8.0。<br>标准化HTTP Client<br>编译器线程的延迟分配。添加了新的命令-XX:+UseDynamicNumberOfCompilerThreads动态控制编译器线程的数量。<br>新的垃圾收集器—ZGC。一种可伸缩的低延迟垃圾收集器(实验性)。<br>Epsilon。一款新的实验性无操作垃圾收集器。Epsilon GC 只负责内存分配，不实现任何内存回收机制。这对于性能测试非常有用，可用于与其他GC对比成本和收益。<br>Lambda参数的局部变量语法。java10中引入的var字段得到了增强，现在可以用在lambda表达式的声明中。如果lambda表达式的其中一个形式参数使用了var，那所有的参数都必须使用var。</p><h2 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.jianshu.com/p/31433bcaa1a5" target="_blank" rel="noopener">JDK 版本变化</a><br>2.<a href="https://www.cnblogs.com/IcanFixIt/p/7131676.html" target="_blank" rel="noopener">Java 9 揭秘</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;记录一下JDK版本的历史更新和重要特性。&lt;/p&gt;
&lt;p&gt;目前JDK更新较快，每半年发布一个版本，但是对于生产环境采用仍然建议使用LTS(长期
      
    
    </summary>
    
      <category term="JDK" scheme="https://victoryofymk.github.io/categories/JDK/"/>
    
    
      <category term="JDK" scheme="https://victoryofymk.github.io/tags/JDK/"/>
    
      <category term="Java" scheme="https://victoryofymk.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(五)：个性化 next theme</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E4%B8%AA%E6%80%A7%E5%8C%96next%E4%B8%BB%E9%A2%98/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo个性化next主题/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><p>主要有以下32种：<br>    • 在右上角或者左上角实现fork me on github<br>    • 添加RSS<br>    • 添加动态背景<br>    • 实现点击出现桃心效果<br>    • 修改文章内链接文本样式<br>    • 修改文章底部的那个带#号的标签<br>    • 在每篇文章末尾统一添加“本文结束”标记<br>    • 修改作者头像并旋转<br>    • 博文压缩<br>    • 修改<code></code>代码块自定义样式<br>    • 侧边栏社交小图标设置<br>    • 主页文章添加阴影效果<br>    • 在网站底部加上访问量<br>    • 添加热度<br>    • 网站底部字数统计<br>    • 添加 README.md 文件<br>    • 设置网站的图标Favicon<br>    • 实现统计功能<br>    • 添加顶部加载条<br>    • 在文章底部增加版权信息<br>    • 添加网易云跟帖(跟帖关闭，已失效，改为来必力)<br>    • 隐藏网页底部powered By Hexo / 强力驱动<br>    • 修改网页底部的桃心<br>    • 文章加密访问<br>    • 添加jiathis分享<br>    • 博文置顶<br>    • 修改字体大小<br>    • 修改打赏字体不闪动<br>    • 自定义鼠标样式<br>    • 为博客加上萌萌的宠物<br>    • DaoVoice 在线联系<br>    • 点击爆炸效果</p><pre><code>下面介绍几种常见配置,其他请参考文末链接</code></pre><h3 id="1-在右上角或者左上角实现fork-me-on-github"><a href="#1-在右上角或者左上角实现fork-me-on-github" class="headerlink" title="1.在右上角或者左上角实现fork me on github"></a>1.在右上角或者左上角实现fork me on github</h3><p>点击这里<a href="https://blog.github.com/2008-12-19-github-ribbons/挑选自己喜欢的样式，并复制代码。" target="_blank" rel="noopener">https://blog.github.com/2008-12-19-github-ribbons/挑选自己喜欢的样式，并复制代码。</a> 例如，我的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://github.com/Ahaochan&quot; class=&quot;&quot; target=&quot;_blank&quot; title=&quot;我的Github&quot; aria-label=&quot;我的Github&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;</span><br><span class="line">  &lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在<div class="headband"></div>的下面)，并把href改为你的github地址</p><h3 id="2-添加RSS"><a href="#2-添加RSS" class="headerlink" title="2.添加RSS"></a>2.添加RSS</h3><p>执行以下命令安装 RSS 插件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>编辑网站根目录下的 _config.yml，添加以下代码开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># RSS订阅支持</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line"># Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><p>NexT 主题，默认就可以；其他主题请参考主题说明，配置完之后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><p>重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。</p><h3 id="3-侧边栏社交小图标设置"><a href="#3-侧边栏社交小图标设置" class="headerlink" title="3. 侧边栏社交小图标设置"></a>3. 侧边栏社交小图标设置</h3><p>打开主题配置文件（_config.yml），配置social</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/yourname || github</span><br><span class="line">  GitHub: https://github.com/victoryofymk || github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  E-Mail: mailto:starlord.yan@gmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br><span class="line">  # Dependencies: exturl: true in Tags Settings section below.</span><br><span class="line">  # To encrypt links above use https://www.base64encode.org</span><br><span class="line">  # Example encoded link: `GitHub: aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ= || github`</span><br><span class="line">  exturl: false</span><br></pre></td></tr></table></figure><h3 id="4-添加热度"><a href="#4-添加热度" class="headerlink" title="4. 添加热度"></a>4. 添加热度</h3><h3 id="5-文章字数统计和阅读时间估计"><a href="#5-文章字数统计和阅读时间估计" class="headerlink" title="5. 文章字数统计和阅读时间估计"></a>5. 文章字数统计和阅读时间估计</h3><p>运行  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>NexT 主题也对这个插件进行了集成，可以进行一些高级设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 「在NexT配置文件里修改」</span><br><span class="line"></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4 # Average Word Length</span><br><span class="line">  wpm: 275 # Words Per Minute</span><br></pre></td></tr></table></figure><h3 id="6-根据标签推荐相关文章"><a href="#6-根据标签推荐相关文章" class="headerlink" title="6. 根据标签推荐相关文章"></a>6. 根据标签推荐相关文章</h3><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure><p> NexT 主题集成了这个插件的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 「在NexT配置文件里修改」</span><br><span class="line"></span><br><span class="line"># Related popular posts</span><br><span class="line"># Dependencies: https://github.com/tea3/hexo-related-popular-posts</span><br><span class="line">related_posts:</span><br><span class="line">  enable: true</span><br><span class="line">  title: # custom header, leave empty to use the default one</span><br><span class="line">  display_in_home: false</span><br><span class="line">  params:</span><br><span class="line">    maxCount: 5</span><br><span class="line">    #PPMixingRate: 0.0</span><br><span class="line">    #isDate: false</span><br><span class="line">    #isImage: false</span><br><span class="line">    #isExcerpt: false</span><br></pre></td></tr></table></figure><h3 id="7-设置阅读访问量"><a href="#7-设置阅读访问量" class="headerlink" title="7. 设置阅读访问量"></a>7. 设置阅读访问量</h3><p>关于Hexo博客的文章阅读量设置问题，常见方案如下：<br>1、不蒜子，仅局限于在文章页面显示阅读数，首页是不显示的。</p><p>打开主题配置文件（_config.yml）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure></p><p>2、LeanCloud<br>打开LeanCloud官网，进入注册页面注册。完成邮箱激活后，点击头像，进入控制台页面，如下：</p><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>创建应用取名test</p><h4 id="创建Class"><a href="#创建Class" class="headerlink" title="创建Class"></a>创建Class</h4><p>创建Class命名为Counter,ACL权限默认即可</p><h4 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h4><p>基本配置<br>编辑主题目录下的site_page/themes/next/_config.yml配置，修改配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: xxx</span><br><span class="line">  app_key: xxx</span><br></pre></td></tr></table></figure><p>其中，app_id和app_key在设置–应用Key中获取</p><h4 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h4><p>为了保证应用的统计计数功能仅应用于自己的博客系统，你可以在应用-&gt;设置-&gt;安全中心的Web安全域名中加入自己的博客域名，以保证数据的调用安全。</p><h4 id="确认其他配置"><a href="#确认其他配置" class="headerlink" title="确认其他配置"></a>确认其他配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">themes\next\layout\_scripts\third-party\lean-analytics.swig  # 确保该文件存在</span><br><span class="line">themes\next\layout\_macro\post.swig                          # 大约171行存在leancloud_visitors相关代码</span><br><span class="line">themes\next\layout\_layout.swig                              # 大约83行引用了lean-analytics.swig文件</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>报错：Cannot read property ‘enable_sync’ of undefined<br>解决：在blog站点下的配置文件_config.yml添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leancloud_counter_security:</span><br><span class="line">  enable_sync: true</span><br><span class="line">  app_id: rjEGiCa******-gzGzoHsz</span><br><span class="line">  app_key: zWE2Bry******8HmPyTpBQa</span><br><span class="line">  username: # Will be asked while deploying if is left blank</span><br><span class="line">  password: # Recommmended to be left blank. Will be asked while deploying if is left blank</span><br></pre></td></tr></table></figure><h3 id="8-添加sitemap和baidusitemap"><a href="#8-添加sitemap和baidusitemap" class="headerlink" title="8. 添加sitemap和baidusitemap"></a>8. 添加sitemap和baidusitemap</h3><p>安装sitemap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>安装baidusitemap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>在博客目录的_config.yml中添加如下代码,并修改url字段的值，其值默认为<a href="http://yoursite.com" target="_blank" rel="noopener">http://yoursite.com</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 自动生成sitemap</span><br><span class="line">sitemap: </span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br><span class="line"></span><br><span class="line">url: https://victoryofymk.github.io</span><br></pre></td></tr></table></figure><h3 id="9-为博客加上萌萌的宠物"><a href="#9-为博客加上萌萌的宠物" class="headerlink" title="9.为博客加上萌萌的宠物"></a>9.为博客加上萌萌的宠物</h3><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure></p><p>请向Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure></p><p>然后hexo clean ，hexo g ，hexo d 就可以看到了。</p><h3 id="10-开启动态背景"><a href="#10-开启动态背景" class="headerlink" title="10.开启动态背景"></a>10.开启动态背景</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure><p>参考的文章：</p><pre><code>1. https://segmentfault.com/a/1190000009544924</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;个性化&quot;&gt;&lt;a href=&quot;#个性化&quot; class=&quot;headerlink&quot; title=&quot;个性化&quot;&gt;&lt;/a&gt;个性化&lt;/h2&gt;&lt;p&gt;主要有以下32种：&lt;br&gt;    • 在右上角或者左上角实现fork me on github&lt;br&gt;    • 添加RSS&lt;br&gt;
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>VUE(一)：VUE简介</title>
    <link href="https://victoryofymk.github.io/2018/10/23/vue%E7%AE%80%E4%BB%8B/"/>
    <id>https://victoryofymk.github.io/2018/10/23/vue简介/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue.js</a>是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js。</p><h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><p>下图不仅概括了MVVM模式（Model-View-ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的<br><img src="https://raw.githubusercontent.com/victoryofymk/victoryofymk.github.io/images/20181025103023.png" alt=""><br>ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。</p><p>当创建了ViewModel后，双向绑定是如何达成的呢？</p><p>首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。<br>从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；<br>从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。</p><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><p>在工程中直接引用vue，后续介绍使用vue-cli搭建vue工程化</p><h3 id="Hello-World示例"><a href="#Hello-World示例" class="headerlink" title="Hello World示例"></a>Hello World示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--这是我们的View--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 这是我们的Model</span><br><span class="line">var exampleData = &#123;</span><br><span class="line">message: &apos;Hello World!&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个 Vue 实例或 &quot;ViewModel&quot;</span><br><span class="line">// 它连接 View 与 Model</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: exampleData</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>使用Vue的过程就是定义MVVM各个组成部分的过程的过程。</p><p>定义View<br>定义Model<br>创建一个Vue实例或”ViewModel”，它用于连接View和Model<br>在创建Vue实例时，需要传入一个选项对象，选项对象可以包含数据、挂载元素、方法、模生命周期钩子等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在这个示例中，选项对象的el属性指向View，el: &apos;#app&apos;表示该Vue实例将挂载到&lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;这个元素；data属性指向Model，data: exampleData表示我们的Model是exampleData对象。</span><br><span class="line">Vue.js有多种数据绑定的语法，最基础的形式是文本插值，使用一对大括号语法，在运行时&#123;&#123; message &#125;&#125;会被数据对象的message属性替换，所以页面上会输出&quot;Hello World!&quot;。</span><br></pre></td></tr></table></figure><h3 id="双向绑定示例"><a href="#双向绑定示例" class="headerlink" title="双向绑定示例"></a>双向绑定示例</h3><p>MVVM模式本身是实现了双向绑定的，在Vue.js中可以使用v-model指令在表单元素上创建双向数据绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这是我们的View--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">将message绑定到文本框，当更改文本框的值时，&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; 中的内容也会被更新。反过来，如果改变message的值，文本框的值也会被更新，我们可以在Chrome控制台进行尝试。</span><br></pre></td></tr></table></figure></p><h3 id="Vue-js的常用指令"><a href="#Vue-js的常用指令" class="headerlink" title="Vue.js的常用指令"></a>Vue.js的常用指令</h3><p>Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v-if指令</span><br><span class="line">v-show指令</span><br><span class="line">v-else指令</span><br><span class="line">v-for指令</span><br><span class="line">v-bind指令</span><br><span class="line">v-on指令</span><br></pre></td></tr></table></figure></p><h4 id="v-if指令"><a href="#v-if指令" class="headerlink" title="v-if指令"></a>v-if指令</h4><p>v-if是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：v-if=”expression”<br>expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;h1&gt;Hello, Vue.js!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-if=&quot;yes&quot;&gt;Yes!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-if=&quot;no&quot;&gt;No!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-if=&quot;name.indexOf(&apos;jack&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">yes: true,</span><br><span class="line">no: false,</span><br><span class="line">age: 28,</span><br><span class="line">name: &apos;keepfool&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>注意：yes, no, age, name这4个变量都来源于Vue实例选项对象的data属性。<br>这段代码使用了4个表达式：</p><ul><li>数据的yes属性为true，所以”Yes!”会被输出；</li><li>数据的no属性为false，所以”No!”不会被输出；</li><li>运算式age &gt;= 25返回true，所以”Age: 28”会被输出；</li><li>运算式name.indexOf(‘jack’) &gt;= 0返回false，所以”Name: keepfool”不会被输出。<br>注意：v-if指令是根据条件表达式的值来执行元素的插入或者删除行为。</li></ul><h4 id="v-show指令"><a href="#v-show指令" class="headerlink" title="v-show指令"></a>v-show指令</h4><p>v-show也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;h1&gt;Hello, Vue.js!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;yes&quot;&gt;Yes!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;no&quot;&gt;No!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;name.indexOf(&apos;jack&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">yes: true,</span><br><span class="line">no: false,</span><br><span class="line">age: 28,</span><br><span class="line">name: &apos;keepfool&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在Chrome控制台更改age属性，使得表达式age &gt;= 25的值为false，可以看到</p><h1>Age: 24</h1>元素被设置了style=”display:none”样式。<p></p><h4 id="v-else指令"><a href="#v-else指令" class="headerlink" title="v-else指令"></a>v-else指令</h4><p>可以用v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;---------------------分割线---------------------&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;name.indexOf(&apos;keep&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Sex: &#123;&#123; sex &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">age: 28,</span><br><span class="line">name: &apos;keepfool&apos;,</span><br><span class="line">sex: &apos;Male&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>v-else元素是否渲染在HTML中，取决于前面使用的是v-if还是v-show指令。<br>这段代码中v-if为true，后面的v-else不会渲染到HTML；v-show为tue，但是后面的v-else仍然渲染到HTML了。</p><h4 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h4><p>v-for指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-for=&quot;item in items&quot;</span><br></pre></td></tr></table></figure><p>items是一个数组，item是当前被遍历的数组元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/demo.css&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;Name&lt;/th&gt;</span><br><span class="line">&lt;th&gt;Age&lt;/th&gt;</span><br><span class="line">&lt;th&gt;Sex&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr v-for=&quot;person in people&quot;&gt;</span><br><span class="line">&lt;td&gt;&#123;&#123; person.name  &#125;&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&#123;&#123; person.age  &#125;&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&#123;&#123; person.sex  &#125;&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">people: [&#123;</span><br><span class="line">name: &apos;Jack&apos;,</span><br><span class="line">age: 30,</span><br><span class="line">sex: &apos;Male&apos;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: &apos;Bill&apos;,</span><br><span class="line">age: 26,</span><br><span class="line">sex: &apos;Male&apos;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: &apos;Tracy&apos;,</span><br><span class="line">age: 22,</span><br><span class="line">sex: &apos;Female&apos;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: &apos;Chris&apos;,</span><br><span class="line">age: 36,</span><br><span class="line">sex: &apos;Male&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="v-bind指"><a href="#v-bind指" class="headerlink" title="v-bind指"></a>v-bind指</h4><p>v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-bind:argument=&quot;expression&quot;</span><br></pre></td></tr></table></figure><p>下面这段代码构建了一个简单的分页条，v-bind指令作用于元素的class特性上。<br>这个指令包含一个表达式，表达式的含义是：高亮当前页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/demo.css&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;ul class=&quot;pagination&quot;&gt;</span><br><span class="line">&lt;li v-for=&quot;n in pageCount&quot;&gt;</span><br><span class="line">&lt;a href=&quot;javascripit:void(0)&quot; v-bind:class=&quot;activeNumber === n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">activeNumber: 1,</span><br><span class="line">pageCount: 10</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="v-on指令"><a href="#v-on指令" class="headerlink" title="v-on指令"></a>v-on指令</h4><p>v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听<a>元素的点击事件：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure><p>有两种形式调用方法：绑定一个方法（让事件指向方法的引用），或者使用内联语句。<br>Greet按钮将它的单击事件直接绑定到greet()方法，而Hi按钮则是调用say()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;!--click事件直接绑定一个方法--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;!--click事件使用内联语句--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;say(&apos;Hi&apos;)&quot;&gt;Hi&lt;/button&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">message: &apos;Hello, Vue.js!&apos;</span><br><span class="line">&#125;,</span><br><span class="line">// 在 `methods` 对象中定义方法</span><br><span class="line">methods: &#123;</span><br><span class="line">greet: function() &#123;</span><br><span class="line">// // 方法内 `this` 指向 vm</span><br><span class="line">alert(this.message)</span><br><span class="line">&#125;,</span><br><span class="line">say: function(msg) &#123;</span><br><span class="line">alert(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="v-bind和v-on的缩写"><a href="#v-bind和v-on的缩写" class="headerlink" title="v-bind和v-on的缩写"></a>v-bind和v-on的缩写</h4><p>Vue.js为最常用的两个指令v-bind和v-on提供了缩写方式。v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--完整语法--&gt;</span><br><span class="line">&lt;a href=&quot;javascripit:void(0)&quot; v-bind:class=&quot;activeNumber === n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br><span class="line">&lt;!--缩写语法--&gt;</span><br><span class="line">&lt;a href=&quot;javascripit:void(0)&quot; :class=&quot;activeNumber=== n + 1 ? &apos;active&apos; : &apos;&apos;&quot;&gt;&#123;&#123; n + 1 &#125;&#125;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--完整语法--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;!--缩写语法--&gt;</span><br><span class="line">&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://victoryofymk.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://victoryofymk.github.io/tags/vue/"/>
    
      <category term="web" scheme="https://victoryofymk.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(二)：关联 github</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E5%85%B3%E8%81%94github/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo关联github/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如victoryofymk.github.io</p><h2 id="修改blog配置"><a href="#修改blog配置" class="headerlink" title="修改blog配置"></a>修改blog配置</h2><p>本地的blog文件夹下内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml </span><br><span class="line">db.json </span><br><span class="line">node_modules </span><br><span class="line">package.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure></p><p>终端cd到blog文件夹下，vim打开_config.yml，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure></p><p>打开后往下滑到最后，修改成下边的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/victoryofymk/victoryofymk.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure></p><p>将repository后victoryofymk换成你自己的用户名</p><p>注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错</p><p>则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username for &apos;xxx&apos;:</span><br><span class="line">Password for &apos;xxx&apos;:</span><br></pre></td></tr></table></figure></p><p>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://victoryofymk.github.io（将victoryofymk换成你的用户名）能看到和打开http://localhost:4000时一样的页面。" target="_blank" rel="noopener">http://victoryofymk.github.io（将victoryofymk换成你的用户名）能看到和打开http://localhost:4000时一样的页面。</a></p><p><strong>注意</strong>：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>再次执行hexo deploy命令。</p><p>未避免每次输入Github用户名和密码的麻烦，可参照下一节</p><h2 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a>添加ssh key到Github</h2><p>1.检查SSH keys是否存在Github<br>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤3将SSH key添加到Github中，否则进入下一步生成SSH key。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure></p><p>2.生成新的ssh key<br>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。<br>3.将ssh key添加到Github中<br>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入Github --&gt; Settings --&gt; SSH keys --&gt; add SSH key:</span><br></pre></td></tr></table></figure></p><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p><h2 id="将个人博客同时部署到-GitHub-和-Coding"><a href="#将个人博客同时部署到-GitHub-和-Coding" class="headerlink" title="将个人博客同时部署到 GitHub 和 Coding"></a>将个人博客同时部署到 GitHub 和 Coding</h2><p>1、首先到 Coding 上注册并开一个项目，项目名称和用户个性后缀相同（方便二级域名访问博客），拿到项目的 https 地址<br>2、打开本地 blog 目录下的 _config.yml 文件，修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">            github: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">            coding: https://git.coding.net/xxx/xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>3、cd 到本地 blog/source 目录下执行如下命令新建 Staticfile 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch Staticfile  #名字必须是Staticfile</span><br></pre></td></tr></table></figure></p><p>原因是 coding.net 需要以这个文件来作为静态文件部署的标志，就是说看到这个 Staticfile 就知道按照静态文件来发布。<br>4、执行发布命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g 、 hexo d</span><br></pre></td></tr></table></figure></p><p>5、个人域名添加两条 CNAME 解析。将 xxx.github.io. 解析为 [海外] ，将 xxx.coding.me. 解析为 [默认]<br>这样就是为了从国内访问 xxx.com 就是访问 Coding 上的博客项目，从国外访问 xxx.com 就是访问 GitHub 上的博客项目。<br>6、到 Coding 上的博客项目主页，点击 Pages服务 输入部署分支 master 立即开启</p><p>这样就可以访问自己在 Coding 上的个人博客了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建仓库&quot;&gt;&lt;a href=&quot;#创建仓库&quot; class=&quot;headerlink&quot; title=&quot;创建仓库&quot;&gt;&lt;/a&gt;创建仓库&lt;/h2&gt;&lt;p&gt;登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如victoryofymk.github.io&lt;
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(三)：创建分类页面</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo创建分类页面/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h2><p>添加一个 分类 页面，并在菜单中显示页面链接。</p><ol><li><p>新建一个页面，命名为 categories 。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories注释去掉，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: / || home</span><br><span class="line"> about: /about/ || user</span><br><span class="line"> tags: /tags/ || tags</span><br><span class="line"> categories: /categories/ || th</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建分类&quot;&gt;&lt;a href=&quot;#创建分类&quot; class=&quot;headerlink&quot; title=&quot;创建分类&quot;&gt;&lt;/a&gt;创建分类&lt;/h2&gt;&lt;p&gt;添加一个 分类 页面，并在菜单中显示页面链接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新建一个页面，命名为 categories 
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(一)：安装 hexo</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E5%AE%89%E8%A3%85/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo安装/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用依赖"><a href="#常用依赖" class="headerlink" title="常用依赖"></a>常用依赖</h2><p>• Hexo - 快速、简洁且高效的博客框架<br>• Github Pages - 完美的静态博客服务器（除大陆网速慢外）<br>• NexT - 一款高质量且简洁优雅的Hexo主题<br>• Travis CI - 一个持续集成测试工具</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>搭建环境：macos</p><p>1.安装node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brew install node</span><br></pre></td></tr></table></figure></p><p>2.安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></p><p>3.安装 hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>终端cd到一个你选定的目录，执行hexo init命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure></p><p>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>执行如下命令，开启hexo服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>此时，浏览器中打开网址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>终端cd到blog文件夹下，执行如下命令新建文章：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#名为postName.md的文件会建在目录/blog/source/_posts下</span><br><span class="line">hexo new &quot;postName&quot;</span><br></pre></td></tr></table></figure></p><p>在blog文件夹目录下执行生成静态页面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate     或者：hexo g</span><br></pre></td></tr></table></figure></p><p>此时若出现如下报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure></p><p>则执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo --save</span><br></pre></td></tr></table></figure></p><p>若无报错，自行忽略此步骤。</p><h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>hexo clean：清空public<br>hexo g：静态文件重新生成<br>hexo d：部署</p><p>hexo generate hexo deploy 简写 hexo g -d</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用依赖&quot;&gt;&lt;a href=&quot;#常用依赖&quot; class=&quot;headerlink&quot; title=&quot;常用依赖&quot;&gt;&lt;/a&gt;常用依赖&lt;/h2&gt;&lt;p&gt;• Hexo - 快速、简洁且高效的博客框架&lt;br&gt;• Github Pages - 完美的静态博客服务器（除大陆网速慢外）
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(四)：安装 theme next</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E5%AE%89%E8%A3%85next%E4%B8%BB%E9%A2%98/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo安装next主题/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装theme"><a href="#安装theme" class="headerlink" title="安装theme"></a>安装theme</h2><p>你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例</p><p>终端cd到 blog 目录下执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>将blog目录下_config.yml里theme的名称landscape修改为next<br>终端cd到blog目录下执行如下命令(每次部署文章的步骤)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">$ hexo g             //生成缓存和静态文件</span><br><span class="line">$ hexo d             //重新部署到服务器</span><br></pre></td></tr></table></figure></p><p>至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。</p><p>升级 nexT 主题，cd 到 blog/themes/next/ 下执行命令 git pull 更新</p><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>NexT 目前支持六种语言版本：<br>    • English<br>    • 中文简体 (zh-Hans)<br>    • French (fr-FR)<br>    • 正体中文 (zh-hk/zh-tw)<br>    • Russian (ru)<br>    • German (de)<br>默认语言是英文。编辑站点的_config.yml，将language字段更改为你所需要的语言版本代号：<br>language: default #默认是英文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br><span class="line">language: fr-FR</span><br><span class="line">language: zh-HK</span><br><span class="line">language: zh-TW</span><br><span class="line">language: en</span><br><span class="line">language: ru</span><br><span class="line">language: de</span><br></pre></td></tr></table></figure></p><h3 id="设置文章目录"><a href="#设置文章目录" class="headerlink" title="设置文章目录"></a>设置文章目录</h3><h3 id="Toc-true"><a href="#Toc-true" class="headerlink" title="Toc true"></a>Toc true</h3><h3 id="设置归档"><a href="#设置归档" class="headerlink" title="设置归档"></a>设置归档</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装theme&quot;&gt;&lt;a href=&quot;#安装theme&quot; class=&quot;headerlink&quot; title=&quot;安装theme&quot;&gt;&lt;/a&gt;安装theme&lt;/h2&gt;&lt;p&gt;你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例&lt;/p
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(十)：使用中的问题</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo常见问题/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Template-render-error"><a href="#Template-render-error" class="headerlink" title="Template render error"></a>Template render error</h3><p>解析异常，通常在hexo g的时候出现，通常是某些代码被解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Template render error: (unknown path)</span><br><span class="line">  Error: template not found: ./comments/livere.swig</span><br></pre></td></tr></table></figure><p>如果让jekyll不解析，使用raw语法，中间写内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% sometag %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h3 id="Found-incompatible-module"><a href="#Found-incompatible-module" class="headerlink" title="Found incompatible module"></a>Found incompatible module</h3><p>使用yarn管理依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error nunjucks@3.1.3: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;&gt;= 6.9.0 &lt;= 11.0.0-0&quot;. Got &quot;11.0.0&quot;</span><br></pre></td></tr></table></figure><p>需要将node降级为7，在travis.yml中修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># node版本</span><br><span class="line">node_js: &quot;7&quot;</span><br></pre></td></tr></table></figure><h3 id="gitalk授权问题"><a href="#gitalk授权问题" class="headerlink" title="gitalk授权问题"></a>gitalk授权问题</h3><p>使用github issue实现hexo评论功能，登陆时无法跳转到有效链接</p><p>解决办法：检查MD文件名称中是否有中文字符，例如：中文冒号：，如果有去掉即可，因为跳转时会转换成英文字符，所以路径就找不到，空格也可能有问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;h3 id=&quot;Template-render-error&quot;&gt;&lt;a href=&quot;#Template-render-error&quot; c
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo(八)：添加其他功能</title>
    <link href="https://victoryofymk.github.io/2018/10/23/Hexo%E6%B7%BB%E5%8A%A0%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD/"/>
    <id>https://victoryofymk.github.io/2018/10/23/Hexo添加其他功能/</id>
    <published>2018-10-23T08:12:48.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为Hexo搜索与统计"><a href="#为Hexo搜索与统计" class="headerlink" title="为Hexo搜索与统计"></a>为Hexo搜索与统计</h2><p>搜索与统计都比较简单，<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">官方文档</a>有详尽的明细,统计推荐不蒜子，简单粗暴。<br>搜索的话我使用的是本地搜索，即Local Search。他的原理是在你本地生成一个xml文件,搜索的时候对这个文件进行检索。下面说说安装步骤<br>1.执行下面2个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p><p>2.打开站点配置文件，新增以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>3.打开主题配置文件，启用本地搜索功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>先来看看hexo官方文档<a href="https://link.zhihu.com/?target=https%253A//hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">资源文件夹</a></p><p>设置好了以后每次你通过 hexo new blognames 在source文件夹下生成一个blognames.md文件以后会自动的生成一个文件夹,该文件夹也是以blognames命名,此时将你想要插入到md中的图片放进去,例如:我放了一个icon.jpg,name你就可以在md中这样引用了<br><img src="icon.jpg" alt="图片描述"><br>注意:按照官方的文档,引用的格式应该是:<img src="/blognames/http://icon.jp" alt="图片描述">,其实不然,因为生成的相应的blognames博文和该资源位于同一个文件夹下,因此还是上面的引用方式是正确的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为Hexo搜索与统计&quot;&gt;&lt;a href=&quot;#为Hexo搜索与统计&quot; class=&quot;headerlink&quot; title=&quot;为Hexo搜索与统计&quot;&gt;&lt;/a&gt;为Hexo搜索与统计&lt;/h2&gt;&lt;p&gt;搜索与统计都比较简单，&lt;a href=&quot;http://theme-next.
      
    
    </summary>
    
      <category term="hexo" scheme="https://victoryofymk.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://victoryofymk.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://victoryofymk.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>nginx项目实践(四)</title>
    <link href="https://victoryofymk.github.io/2017/09/19/nginx%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5(%E5%9B%9B)/"/>
    <id>https://victoryofymk.github.io/2017/09/19/nginx项目实践(四)/</id>
    <published>2017-09-19T08:14:49.000Z</published>
    <updated>2018-11-14T06:37:06.755Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="nginx教程" scheme="https://victoryofymk.github.io/categories/nginx%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="nginx" scheme="https://victoryofymk.github.io/tags/nginx/"/>
    
      <category term="代理" scheme="https://victoryofymk.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
